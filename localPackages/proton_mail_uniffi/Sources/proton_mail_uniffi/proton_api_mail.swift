// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(proton_mail_uniffi_ffi)
import proton_mail_uniffi_ffi
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_proton_api_mail_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_proton_api_mail_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public struct AttachmentMetadata {
    public var id: AttachmentId
    public var size: UInt64
    public var name: String
    public var mimeType: String
    public var disposition: Disposition

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: AttachmentId, size: UInt64, name: String, mimeType: String, disposition: Disposition) {
        self.id = id
        self.size = size
        self.name = name
        self.mimeType = mimeType
        self.disposition = disposition
    }
}


extension AttachmentMetadata: Sendable {} 
extension AttachmentMetadata: Equatable, Hashable {
    public static func ==(lhs: AttachmentMetadata, rhs: AttachmentMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.disposition != rhs.disposition {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(size)
        hasher.combine(name)
        hasher.combine(mimeType)
        hasher.combine(disposition)
    }
}


public struct FfiConverterTypeAttachmentMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentMetadata {
        return
            try AttachmentMetadata(
                id: FfiConverterTypeAttachmentId.read(from: &buf), 
                size: FfiConverterUInt64.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                mimeType: FfiConverterString.read(from: &buf), 
                disposition: FfiConverterTypeDisposition.read(from: &buf)
        )
    }

    public static func write(_ value: AttachmentMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeAttachmentId.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterTypeDisposition.write(value.disposition, into: &buf)
    }
}


public func FfiConverterTypeAttachmentMetadata_lift(_ buf: RustBuffer) throws -> AttachmentMetadata {
    return try FfiConverterTypeAttachmentMetadata.lift(buf)
}

public func FfiConverterTypeAttachmentMetadata_lower(_ value: AttachmentMetadata) -> RustBuffer {
    return FfiConverterTypeAttachmentMetadata.lower(value)
}


public struct Label {
    public var id: LabelId
    public var parentId: LabelId?
    public var name: String
    public var path: String?
    public var color: String
    public var labelType: LabelType
    public var notify: Bool
    public var display: Bool
    public var sticky: Bool
    public var expanded: Bool
    public var order: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: LabelId, parentId: LabelId?, name: String, path: String?, color: String, labelType: LabelType, notify: Bool, display: Bool, sticky: Bool, expanded: Bool, order: UInt32) {
        self.id = id
        self.parentId = parentId
        self.name = name
        self.path = path
        self.color = color
        self.labelType = labelType
        self.notify = notify
        self.display = display
        self.sticky = sticky
        self.expanded = expanded
        self.order = order
    }
}


extension Label: Sendable {} 
extension Label: Equatable, Hashable {
    public static func ==(lhs: Label, rhs: Label) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.parentId != rhs.parentId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.labelType != rhs.labelType {
            return false
        }
        if lhs.notify != rhs.notify {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.sticky != rhs.sticky {
            return false
        }
        if lhs.expanded != rhs.expanded {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(parentId)
        hasher.combine(name)
        hasher.combine(path)
        hasher.combine(color)
        hasher.combine(labelType)
        hasher.combine(notify)
        hasher.combine(display)
        hasher.combine(sticky)
        hasher.combine(expanded)
        hasher.combine(order)
    }
}


public struct FfiConverterTypeLabel: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Label {
        return
            try Label(
                id: FfiConverterTypeLabelId.read(from: &buf), 
                parentId: FfiConverterOptionTypeLabelId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                path: FfiConverterOptionString.read(from: &buf), 
                color: FfiConverterString.read(from: &buf), 
                labelType: FfiConverterTypeLabelType.read(from: &buf), 
                notify: FfiConverterBool.read(from: &buf), 
                display: FfiConverterBool.read(from: &buf), 
                sticky: FfiConverterBool.read(from: &buf), 
                expanded: FfiConverterBool.read(from: &buf), 
                order: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Label, into buf: inout [UInt8]) {
        FfiConverterTypeLabelId.write(value.id, into: &buf)
        FfiConverterOptionTypeLabelId.write(value.parentId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.path, into: &buf)
        FfiConverterString.write(value.color, into: &buf)
        FfiConverterTypeLabelType.write(value.labelType, into: &buf)
        FfiConverterBool.write(value.notify, into: &buf)
        FfiConverterBool.write(value.display, into: &buf)
        FfiConverterBool.write(value.sticky, into: &buf)
        FfiConverterBool.write(value.expanded, into: &buf)
        FfiConverterUInt32.write(value.order, into: &buf)
    }
}


public func FfiConverterTypeLabel_lift(_ buf: RustBuffer) throws -> Label {
    return try FfiConverterTypeLabel.lift(buf)
}

public func FfiConverterTypeLabel_lower(_ value: Label) -> RustBuffer {
    return FfiConverterTypeLabel.lower(value)
}


public struct MailSettings {
    public var displayName: String
    public var signature: String
    public var theme: String
    public var autoSaveContacts: Bool
    public var composerMode: MailSettingsComposerMode
    public var messageButtons: MailSettingsMessageButtons
    public var showImages: MailSettingsShowImages
    public var showMoved: MailSettingsShowMoved
    public var autoDeleteSpamAndTrashDays: UInt32?
    public var almostAllMail: MailSettingsAlmostAllMail
    public var nextMessageOnMove: MailSettingsNextMessageOnMove?
    public var viewMode: MailSettingsViewMode
    public var viewLayout: MailSettingsViewLayout
    public var swipeLeft: MailSettingsSwipeAction
    public var swipeRight: MailSettingsSwipeAction
    public var shortcuts: Bool
    public var pmSignature: MailSettingsPmSignature
    public var pmSignatureReferralLink: Bool
    public var imageProxy: UInt32
    public var numMessagePerPage: UInt32
    public var draftMimeType: String
    public var receiveMimeType: String
    public var showMimeType: String
    public var enableFolderColor: Bool
    public var inheritParentFolderColor: Bool
    public var submissionAccess: Bool
    public var rightToLeft: MailSettingsComposerDirection
    public var attachPublicKey: Bool
    public var sign: Bool
    public var pgpScheme: MailSettingsPgpScheme
    public var promptPin: Bool
    public var stickyLabels: Bool
    public var confirmLink: Bool
    public var delaySendSeconds: UInt32
    public var fontFace: String?
    public var spamAction: MailSettingsSpamAction?
    public var blockSenderConfirmation: Bool?
    public var mobileSettings: MailSettingsMobileSettings?
    public var hideRemoteImages: Bool
    public var hideSenderImages: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: String, signature: String, theme: String, autoSaveContacts: Bool, composerMode: MailSettingsComposerMode, messageButtons: MailSettingsMessageButtons, showImages: MailSettingsShowImages, showMoved: MailSettingsShowMoved, autoDeleteSpamAndTrashDays: UInt32?, almostAllMail: MailSettingsAlmostAllMail, nextMessageOnMove: MailSettingsNextMessageOnMove?, viewMode: MailSettingsViewMode, viewLayout: MailSettingsViewLayout, swipeLeft: MailSettingsSwipeAction, swipeRight: MailSettingsSwipeAction, shortcuts: Bool, pmSignature: MailSettingsPmSignature, pmSignatureReferralLink: Bool, imageProxy: UInt32, numMessagePerPage: UInt32, draftMimeType: String, receiveMimeType: String, showMimeType: String, enableFolderColor: Bool, inheritParentFolderColor: Bool, submissionAccess: Bool, rightToLeft: MailSettingsComposerDirection, attachPublicKey: Bool, sign: Bool, pgpScheme: MailSettingsPgpScheme, promptPin: Bool, stickyLabels: Bool, confirmLink: Bool, delaySendSeconds: UInt32, fontFace: String?, spamAction: MailSettingsSpamAction?, blockSenderConfirmation: Bool?, mobileSettings: MailSettingsMobileSettings?, hideRemoteImages: Bool, hideSenderImages: Bool) {
        self.displayName = displayName
        self.signature = signature
        self.theme = theme
        self.autoSaveContacts = autoSaveContacts
        self.composerMode = composerMode
        self.messageButtons = messageButtons
        self.showImages = showImages
        self.showMoved = showMoved
        self.autoDeleteSpamAndTrashDays = autoDeleteSpamAndTrashDays
        self.almostAllMail = almostAllMail
        self.nextMessageOnMove = nextMessageOnMove
        self.viewMode = viewMode
        self.viewLayout = viewLayout
        self.swipeLeft = swipeLeft
        self.swipeRight = swipeRight
        self.shortcuts = shortcuts
        self.pmSignature = pmSignature
        self.pmSignatureReferralLink = pmSignatureReferralLink
        self.imageProxy = imageProxy
        self.numMessagePerPage = numMessagePerPage
        self.draftMimeType = draftMimeType
        self.receiveMimeType = receiveMimeType
        self.showMimeType = showMimeType
        self.enableFolderColor = enableFolderColor
        self.inheritParentFolderColor = inheritParentFolderColor
        self.submissionAccess = submissionAccess
        self.rightToLeft = rightToLeft
        self.attachPublicKey = attachPublicKey
        self.sign = sign
        self.pgpScheme = pgpScheme
        self.promptPin = promptPin
        self.stickyLabels = stickyLabels
        self.confirmLink = confirmLink
        self.delaySendSeconds = delaySendSeconds
        self.fontFace = fontFace
        self.spamAction = spamAction
        self.blockSenderConfirmation = blockSenderConfirmation
        self.mobileSettings = mobileSettings
        self.hideRemoteImages = hideRemoteImages
        self.hideSenderImages = hideSenderImages
    }
}


extension MailSettings: Sendable {} 
extension MailSettings: Equatable, Hashable {
    public static func ==(lhs: MailSettings, rhs: MailSettings) -> Bool {
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.theme != rhs.theme {
            return false
        }
        if lhs.autoSaveContacts != rhs.autoSaveContacts {
            return false
        }
        if lhs.composerMode != rhs.composerMode {
            return false
        }
        if lhs.messageButtons != rhs.messageButtons {
            return false
        }
        if lhs.showImages != rhs.showImages {
            return false
        }
        if lhs.showMoved != rhs.showMoved {
            return false
        }
        if lhs.autoDeleteSpamAndTrashDays != rhs.autoDeleteSpamAndTrashDays {
            return false
        }
        if lhs.almostAllMail != rhs.almostAllMail {
            return false
        }
        if lhs.nextMessageOnMove != rhs.nextMessageOnMove {
            return false
        }
        if lhs.viewMode != rhs.viewMode {
            return false
        }
        if lhs.viewLayout != rhs.viewLayout {
            return false
        }
        if lhs.swipeLeft != rhs.swipeLeft {
            return false
        }
        if lhs.swipeRight != rhs.swipeRight {
            return false
        }
        if lhs.shortcuts != rhs.shortcuts {
            return false
        }
        if lhs.pmSignature != rhs.pmSignature {
            return false
        }
        if lhs.pmSignatureReferralLink != rhs.pmSignatureReferralLink {
            return false
        }
        if lhs.imageProxy != rhs.imageProxy {
            return false
        }
        if lhs.numMessagePerPage != rhs.numMessagePerPage {
            return false
        }
        if lhs.draftMimeType != rhs.draftMimeType {
            return false
        }
        if lhs.receiveMimeType != rhs.receiveMimeType {
            return false
        }
        if lhs.showMimeType != rhs.showMimeType {
            return false
        }
        if lhs.enableFolderColor != rhs.enableFolderColor {
            return false
        }
        if lhs.inheritParentFolderColor != rhs.inheritParentFolderColor {
            return false
        }
        if lhs.submissionAccess != rhs.submissionAccess {
            return false
        }
        if lhs.rightToLeft != rhs.rightToLeft {
            return false
        }
        if lhs.attachPublicKey != rhs.attachPublicKey {
            return false
        }
        if lhs.sign != rhs.sign {
            return false
        }
        if lhs.pgpScheme != rhs.pgpScheme {
            return false
        }
        if lhs.promptPin != rhs.promptPin {
            return false
        }
        if lhs.stickyLabels != rhs.stickyLabels {
            return false
        }
        if lhs.confirmLink != rhs.confirmLink {
            return false
        }
        if lhs.delaySendSeconds != rhs.delaySendSeconds {
            return false
        }
        if lhs.fontFace != rhs.fontFace {
            return false
        }
        if lhs.spamAction != rhs.spamAction {
            return false
        }
        if lhs.blockSenderConfirmation != rhs.blockSenderConfirmation {
            return false
        }
        if lhs.mobileSettings != rhs.mobileSettings {
            return false
        }
        if lhs.hideRemoteImages != rhs.hideRemoteImages {
            return false
        }
        if lhs.hideSenderImages != rhs.hideSenderImages {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(displayName)
        hasher.combine(signature)
        hasher.combine(theme)
        hasher.combine(autoSaveContacts)
        hasher.combine(composerMode)
        hasher.combine(messageButtons)
        hasher.combine(showImages)
        hasher.combine(showMoved)
        hasher.combine(autoDeleteSpamAndTrashDays)
        hasher.combine(almostAllMail)
        hasher.combine(nextMessageOnMove)
        hasher.combine(viewMode)
        hasher.combine(viewLayout)
        hasher.combine(swipeLeft)
        hasher.combine(swipeRight)
        hasher.combine(shortcuts)
        hasher.combine(pmSignature)
        hasher.combine(pmSignatureReferralLink)
        hasher.combine(imageProxy)
        hasher.combine(numMessagePerPage)
        hasher.combine(draftMimeType)
        hasher.combine(receiveMimeType)
        hasher.combine(showMimeType)
        hasher.combine(enableFolderColor)
        hasher.combine(inheritParentFolderColor)
        hasher.combine(submissionAccess)
        hasher.combine(rightToLeft)
        hasher.combine(attachPublicKey)
        hasher.combine(sign)
        hasher.combine(pgpScheme)
        hasher.combine(promptPin)
        hasher.combine(stickyLabels)
        hasher.combine(confirmLink)
        hasher.combine(delaySendSeconds)
        hasher.combine(fontFace)
        hasher.combine(spamAction)
        hasher.combine(blockSenderConfirmation)
        hasher.combine(mobileSettings)
        hasher.combine(hideRemoteImages)
        hasher.combine(hideSenderImages)
    }
}


public struct FfiConverterTypeMailSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettings {
        return
            try MailSettings(
                displayName: FfiConverterString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf), 
                theme: FfiConverterString.read(from: &buf), 
                autoSaveContacts: FfiConverterBool.read(from: &buf), 
                composerMode: FfiConverterTypeMailSettingsComposerMode.read(from: &buf), 
                messageButtons: FfiConverterTypeMailSettingsMessageButtons.read(from: &buf), 
                showImages: FfiConverterTypeMailSettingsShowImages.read(from: &buf), 
                showMoved: FfiConverterTypeMailSettingsShowMoved.read(from: &buf), 
                autoDeleteSpamAndTrashDays: FfiConverterOptionUInt32.read(from: &buf), 
                almostAllMail: FfiConverterTypeMailSettingsAlmostAllMail.read(from: &buf), 
                nextMessageOnMove: FfiConverterOptionTypeMailSettingsNextMessageOnMove.read(from: &buf), 
                viewMode: FfiConverterTypeMailSettingsViewMode.read(from: &buf), 
                viewLayout: FfiConverterTypeMailSettingsViewLayout.read(from: &buf), 
                swipeLeft: FfiConverterTypeMailSettingsSwipeAction.read(from: &buf), 
                swipeRight: FfiConverterTypeMailSettingsSwipeAction.read(from: &buf), 
                shortcuts: FfiConverterBool.read(from: &buf), 
                pmSignature: FfiConverterTypeMailSettingsPMSignature.read(from: &buf), 
                pmSignatureReferralLink: FfiConverterBool.read(from: &buf), 
                imageProxy: FfiConverterUInt32.read(from: &buf), 
                numMessagePerPage: FfiConverterUInt32.read(from: &buf), 
                draftMimeType: FfiConverterString.read(from: &buf), 
                receiveMimeType: FfiConverterString.read(from: &buf), 
                showMimeType: FfiConverterString.read(from: &buf), 
                enableFolderColor: FfiConverterBool.read(from: &buf), 
                inheritParentFolderColor: FfiConverterBool.read(from: &buf), 
                submissionAccess: FfiConverterBool.read(from: &buf), 
                rightToLeft: FfiConverterTypeMailSettingsComposerDirection.read(from: &buf), 
                attachPublicKey: FfiConverterBool.read(from: &buf), 
                sign: FfiConverterBool.read(from: &buf), 
                pgpScheme: FfiConverterTypeMailSettingsPGPScheme.read(from: &buf), 
                promptPin: FfiConverterBool.read(from: &buf), 
                stickyLabels: FfiConverterBool.read(from: &buf), 
                confirmLink: FfiConverterBool.read(from: &buf), 
                delaySendSeconds: FfiConverterUInt32.read(from: &buf), 
                fontFace: FfiConverterOptionString.read(from: &buf), 
                spamAction: FfiConverterOptionTypeMailSettingsSpamAction.read(from: &buf), 
                blockSenderConfirmation: FfiConverterOptionBool.read(from: &buf), 
                mobileSettings: FfiConverterOptionTypeMailSettingsMobileSettings.read(from: &buf), 
                hideRemoteImages: FfiConverterBool.read(from: &buf), 
                hideSenderImages: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MailSettings, into buf: inout [UInt8]) {
        FfiConverterString.write(value.displayName, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
        FfiConverterString.write(value.theme, into: &buf)
        FfiConverterBool.write(value.autoSaveContacts, into: &buf)
        FfiConverterTypeMailSettingsComposerMode.write(value.composerMode, into: &buf)
        FfiConverterTypeMailSettingsMessageButtons.write(value.messageButtons, into: &buf)
        FfiConverterTypeMailSettingsShowImages.write(value.showImages, into: &buf)
        FfiConverterTypeMailSettingsShowMoved.write(value.showMoved, into: &buf)
        FfiConverterOptionUInt32.write(value.autoDeleteSpamAndTrashDays, into: &buf)
        FfiConverterTypeMailSettingsAlmostAllMail.write(value.almostAllMail, into: &buf)
        FfiConverterOptionTypeMailSettingsNextMessageOnMove.write(value.nextMessageOnMove, into: &buf)
        FfiConverterTypeMailSettingsViewMode.write(value.viewMode, into: &buf)
        FfiConverterTypeMailSettingsViewLayout.write(value.viewLayout, into: &buf)
        FfiConverterTypeMailSettingsSwipeAction.write(value.swipeLeft, into: &buf)
        FfiConverterTypeMailSettingsSwipeAction.write(value.swipeRight, into: &buf)
        FfiConverterBool.write(value.shortcuts, into: &buf)
        FfiConverterTypeMailSettingsPMSignature.write(value.pmSignature, into: &buf)
        FfiConverterBool.write(value.pmSignatureReferralLink, into: &buf)
        FfiConverterUInt32.write(value.imageProxy, into: &buf)
        FfiConverterUInt32.write(value.numMessagePerPage, into: &buf)
        FfiConverterString.write(value.draftMimeType, into: &buf)
        FfiConverterString.write(value.receiveMimeType, into: &buf)
        FfiConverterString.write(value.showMimeType, into: &buf)
        FfiConverterBool.write(value.enableFolderColor, into: &buf)
        FfiConverterBool.write(value.inheritParentFolderColor, into: &buf)
        FfiConverterBool.write(value.submissionAccess, into: &buf)
        FfiConverterTypeMailSettingsComposerDirection.write(value.rightToLeft, into: &buf)
        FfiConverterBool.write(value.attachPublicKey, into: &buf)
        FfiConverterBool.write(value.sign, into: &buf)
        FfiConverterTypeMailSettingsPGPScheme.write(value.pgpScheme, into: &buf)
        FfiConverterBool.write(value.promptPin, into: &buf)
        FfiConverterBool.write(value.stickyLabels, into: &buf)
        FfiConverterBool.write(value.confirmLink, into: &buf)
        FfiConverterUInt32.write(value.delaySendSeconds, into: &buf)
        FfiConverterOptionString.write(value.fontFace, into: &buf)
        FfiConverterOptionTypeMailSettingsSpamAction.write(value.spamAction, into: &buf)
        FfiConverterOptionBool.write(value.blockSenderConfirmation, into: &buf)
        FfiConverterOptionTypeMailSettingsMobileSettings.write(value.mobileSettings, into: &buf)
        FfiConverterBool.write(value.hideRemoteImages, into: &buf)
        FfiConverterBool.write(value.hideSenderImages, into: &buf)
    }
}


public func FfiConverterTypeMailSettings_lift(_ buf: RustBuffer) throws -> MailSettings {
    return try FfiConverterTypeMailSettings.lift(buf)
}

public func FfiConverterTypeMailSettings_lower(_ value: MailSettings) -> RustBuffer {
    return FfiConverterTypeMailSettings.lower(value)
}


public struct MailSettingsMobileSetting {
    public var isCustom: Bool
    public var actions: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isCustom: Bool, actions: [String]) {
        self.isCustom = isCustom
        self.actions = actions
    }
}


extension MailSettingsMobileSetting: Sendable {} 
extension MailSettingsMobileSetting: Equatable, Hashable {
    public static func ==(lhs: MailSettingsMobileSetting, rhs: MailSettingsMobileSetting) -> Bool {
        if lhs.isCustom != rhs.isCustom {
            return false
        }
        if lhs.actions != rhs.actions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCustom)
        hasher.combine(actions)
    }
}


public struct FfiConverterTypeMailSettingsMobileSetting: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsMobileSetting {
        return
            try MailSettingsMobileSetting(
                isCustom: FfiConverterBool.read(from: &buf), 
                actions: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: MailSettingsMobileSetting, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCustom, into: &buf)
        FfiConverterSequenceString.write(value.actions, into: &buf)
    }
}


public func FfiConverterTypeMailSettingsMobileSetting_lift(_ buf: RustBuffer) throws -> MailSettingsMobileSetting {
    return try FfiConverterTypeMailSettingsMobileSetting.lift(buf)
}

public func FfiConverterTypeMailSettingsMobileSetting_lower(_ value: MailSettingsMobileSetting) -> RustBuffer {
    return FfiConverterTypeMailSettingsMobileSetting.lower(value)
}


public struct MailSettingsMobileSettings {
    public var messageToolbar: MailSettingsMobileSetting
    public var conversationToolbar: MailSettingsMobileSetting
    public var listToolbar: MailSettingsMobileSetting

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(messageToolbar: MailSettingsMobileSetting, conversationToolbar: MailSettingsMobileSetting, listToolbar: MailSettingsMobileSetting) {
        self.messageToolbar = messageToolbar
        self.conversationToolbar = conversationToolbar
        self.listToolbar = listToolbar
    }
}


extension MailSettingsMobileSettings: Sendable {} 
extension MailSettingsMobileSettings: Equatable, Hashable {
    public static func ==(lhs: MailSettingsMobileSettings, rhs: MailSettingsMobileSettings) -> Bool {
        if lhs.messageToolbar != rhs.messageToolbar {
            return false
        }
        if lhs.conversationToolbar != rhs.conversationToolbar {
            return false
        }
        if lhs.listToolbar != rhs.listToolbar {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageToolbar)
        hasher.combine(conversationToolbar)
        hasher.combine(listToolbar)
    }
}


public struct FfiConverterTypeMailSettingsMobileSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsMobileSettings {
        return
            try MailSettingsMobileSettings(
                messageToolbar: FfiConverterTypeMailSettingsMobileSetting.read(from: &buf), 
                conversationToolbar: FfiConverterTypeMailSettingsMobileSetting.read(from: &buf), 
                listToolbar: FfiConverterTypeMailSettingsMobileSetting.read(from: &buf)
        )
    }

    public static func write(_ value: MailSettingsMobileSettings, into buf: inout [UInt8]) {
        FfiConverterTypeMailSettingsMobileSetting.write(value.messageToolbar, into: &buf)
        FfiConverterTypeMailSettingsMobileSetting.write(value.conversationToolbar, into: &buf)
        FfiConverterTypeMailSettingsMobileSetting.write(value.listToolbar, into: &buf)
    }
}


public func FfiConverterTypeMailSettingsMobileSettings_lift(_ buf: RustBuffer) throws -> MailSettingsMobileSettings {
    return try FfiConverterTypeMailSettingsMobileSettings.lift(buf)
}

public func FfiConverterTypeMailSettingsMobileSettings_lower(_ value: MailSettingsMobileSettings) -> RustBuffer {
    return FfiConverterTypeMailSettingsMobileSettings.lower(value)
}


public struct MessageAddress {
    public var address: String
    public var name: String
    public var isProton: Bool
    public var displaySenderImage: Bool
    public var isSimpleLogin: Bool
    public var bimiSelector: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, name: String, isProton: Bool, displaySenderImage: Bool, isSimpleLogin: Bool, bimiSelector: String?) {
        self.address = address
        self.name = name
        self.isProton = isProton
        self.displaySenderImage = displaySenderImage
        self.isSimpleLogin = isSimpleLogin
        self.bimiSelector = bimiSelector
    }
}


extension MessageAddress: Sendable {} 
extension MessageAddress: Equatable, Hashable {
    public static func ==(lhs: MessageAddress, rhs: MessageAddress) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.isProton != rhs.isProton {
            return false
        }
        if lhs.displaySenderImage != rhs.displaySenderImage {
            return false
        }
        if lhs.isSimpleLogin != rhs.isSimpleLogin {
            return false
        }
        if lhs.bimiSelector != rhs.bimiSelector {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(name)
        hasher.combine(isProton)
        hasher.combine(displaySenderImage)
        hasher.combine(isSimpleLogin)
        hasher.combine(bimiSelector)
    }
}


public struct FfiConverterTypeMessageAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageAddress {
        return
            try MessageAddress(
                address: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                isProton: FfiConverterBool.read(from: &buf), 
                displaySenderImage: FfiConverterBool.read(from: &buf), 
                isSimpleLogin: FfiConverterBool.read(from: &buf), 
                bimiSelector: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: MessageAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterBool.write(value.isProton, into: &buf)
        FfiConverterBool.write(value.displaySenderImage, into: &buf)
        FfiConverterBool.write(value.isSimpleLogin, into: &buf)
        FfiConverterOptionString.write(value.bimiSelector, into: &buf)
    }
}


public func FfiConverterTypeMessageAddress_lift(_ buf: RustBuffer) throws -> MessageAddress {
    return try FfiConverterTypeMessageAddress.lift(buf)
}

public func FfiConverterTypeMessageAddress_lower(_ value: MessageAddress) -> RustBuffer {
    return FfiConverterTypeMessageAddress.lower(value)
}


public struct MessageMetadata {
    public var id: MessageId
    public var conversationId: ConversationId
    public var order: UInt64
    public var addressId: AddressId
    public var labelIds: [LabelId]
    public var externalId: ExternalId?
    public var subject: String
    public var sender: MessageAddress
    public var toList: [MessageAddress]
    public var ccList: [MessageAddress]
    public var bccList: [MessageAddress]
    public var replyTos: [MessageAddress]
    public var flags: UInt64
    public var time: UInt64
    public var size: UInt64
    public var unread: Bool
    public var isReplied: Bool
    public var isRepliedAll: Bool
    public var isForwarded: Bool
    public var expirationTime: UInt64
    public var numAttachments: UInt32
    public var attachmentsMetadata: [AttachmentMetadata]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: MessageId, conversationId: ConversationId, order: UInt64, addressId: AddressId, labelIds: [LabelId], externalId: ExternalId?, subject: String, sender: MessageAddress, toList: [MessageAddress], ccList: [MessageAddress], bccList: [MessageAddress], replyTos: [MessageAddress], flags: UInt64, time: UInt64, size: UInt64, unread: Bool, isReplied: Bool, isRepliedAll: Bool, isForwarded: Bool, expirationTime: UInt64, numAttachments: UInt32, attachmentsMetadata: [AttachmentMetadata]) {
        self.id = id
        self.conversationId = conversationId
        self.order = order
        self.addressId = addressId
        self.labelIds = labelIds
        self.externalId = externalId
        self.subject = subject
        self.sender = sender
        self.toList = toList
        self.ccList = ccList
        self.bccList = bccList
        self.replyTos = replyTos
        self.flags = flags
        self.time = time
        self.size = size
        self.unread = unread
        self.isReplied = isReplied
        self.isRepliedAll = isRepliedAll
        self.isForwarded = isForwarded
        self.expirationTime = expirationTime
        self.numAttachments = numAttachments
        self.attachmentsMetadata = attachmentsMetadata
    }
}


extension MessageMetadata: Sendable {} 
extension MessageMetadata: Equatable, Hashable {
    public static func ==(lhs: MessageMetadata, rhs: MessageMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.conversationId != rhs.conversationId {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        if lhs.addressId != rhs.addressId {
            return false
        }
        if lhs.labelIds != rhs.labelIds {
            return false
        }
        if lhs.externalId != rhs.externalId {
            return false
        }
        if lhs.subject != rhs.subject {
            return false
        }
        if lhs.sender != rhs.sender {
            return false
        }
        if lhs.toList != rhs.toList {
            return false
        }
        if lhs.ccList != rhs.ccList {
            return false
        }
        if lhs.bccList != rhs.bccList {
            return false
        }
        if lhs.replyTos != rhs.replyTos {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.time != rhs.time {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.unread != rhs.unread {
            return false
        }
        if lhs.isReplied != rhs.isReplied {
            return false
        }
        if lhs.isRepliedAll != rhs.isRepliedAll {
            return false
        }
        if lhs.isForwarded != rhs.isForwarded {
            return false
        }
        if lhs.expirationTime != rhs.expirationTime {
            return false
        }
        if lhs.numAttachments != rhs.numAttachments {
            return false
        }
        if lhs.attachmentsMetadata != rhs.attachmentsMetadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(conversationId)
        hasher.combine(order)
        hasher.combine(addressId)
        hasher.combine(labelIds)
        hasher.combine(externalId)
        hasher.combine(subject)
        hasher.combine(sender)
        hasher.combine(toList)
        hasher.combine(ccList)
        hasher.combine(bccList)
        hasher.combine(replyTos)
        hasher.combine(flags)
        hasher.combine(time)
        hasher.combine(size)
        hasher.combine(unread)
        hasher.combine(isReplied)
        hasher.combine(isRepliedAll)
        hasher.combine(isForwarded)
        hasher.combine(expirationTime)
        hasher.combine(numAttachments)
        hasher.combine(attachmentsMetadata)
    }
}


public struct FfiConverterTypeMessageMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageMetadata {
        return
            try MessageMetadata(
                id: FfiConverterTypeMessageId.read(from: &buf), 
                conversationId: FfiConverterTypeConversationId.read(from: &buf), 
                order: FfiConverterUInt64.read(from: &buf), 
                addressId: FfiConverterTypeAddressId.read(from: &buf), 
                labelIds: FfiConverterSequenceTypeLabelId.read(from: &buf), 
                externalId: FfiConverterOptionTypeExternalId.read(from: &buf), 
                subject: FfiConverterString.read(from: &buf), 
                sender: FfiConverterTypeMessageAddress.read(from: &buf), 
                toList: FfiConverterSequenceTypeMessageAddress.read(from: &buf), 
                ccList: FfiConverterSequenceTypeMessageAddress.read(from: &buf), 
                bccList: FfiConverterSequenceTypeMessageAddress.read(from: &buf), 
                replyTos: FfiConverterSequenceTypeMessageAddress.read(from: &buf), 
                flags: FfiConverterUInt64.read(from: &buf), 
                time: FfiConverterUInt64.read(from: &buf), 
                size: FfiConverterUInt64.read(from: &buf), 
                unread: FfiConverterBool.read(from: &buf), 
                isReplied: FfiConverterBool.read(from: &buf), 
                isRepliedAll: FfiConverterBool.read(from: &buf), 
                isForwarded: FfiConverterBool.read(from: &buf), 
                expirationTime: FfiConverterUInt64.read(from: &buf), 
                numAttachments: FfiConverterUInt32.read(from: &buf), 
                attachmentsMetadata: FfiConverterSequenceTypeAttachmentMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: MessageMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeMessageId.write(value.id, into: &buf)
        FfiConverterTypeConversationId.write(value.conversationId, into: &buf)
        FfiConverterUInt64.write(value.order, into: &buf)
        FfiConverterTypeAddressId.write(value.addressId, into: &buf)
        FfiConverterSequenceTypeLabelId.write(value.labelIds, into: &buf)
        FfiConverterOptionTypeExternalId.write(value.externalId, into: &buf)
        FfiConverterString.write(value.subject, into: &buf)
        FfiConverterTypeMessageAddress.write(value.sender, into: &buf)
        FfiConverterSequenceTypeMessageAddress.write(value.toList, into: &buf)
        FfiConverterSequenceTypeMessageAddress.write(value.ccList, into: &buf)
        FfiConverterSequenceTypeMessageAddress.write(value.bccList, into: &buf)
        FfiConverterSequenceTypeMessageAddress.write(value.replyTos, into: &buf)
        FfiConverterUInt64.write(value.flags, into: &buf)
        FfiConverterUInt64.write(value.time, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterBool.write(value.unread, into: &buf)
        FfiConverterBool.write(value.isReplied, into: &buf)
        FfiConverterBool.write(value.isRepliedAll, into: &buf)
        FfiConverterBool.write(value.isForwarded, into: &buf)
        FfiConverterUInt64.write(value.expirationTime, into: &buf)
        FfiConverterUInt32.write(value.numAttachments, into: &buf)
        FfiConverterSequenceTypeAttachmentMetadata.write(value.attachmentsMetadata, into: &buf)
    }
}


public func FfiConverterTypeMessageMetadata_lift(_ buf: RustBuffer) throws -> MessageMetadata {
    return try FfiConverterTypeMessageMetadata.lift(buf)
}

public func FfiConverterTypeMessageMetadata_lower(_ value: MessageMetadata) -> RustBuffer {
    return FfiConverterTypeMessageMetadata.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AddressStatus : UInt8 {
    
    case disabled = 0
    case enabled = 1
    case deleting = 2
}


public struct FfiConverterTypeAddressStatus: FfiConverterRustBuffer {
    typealias SwiftType = AddressStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disabled
        
        case 2: return .enabled
        
        case 3: return .deleting
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disabled:
            writeInt(&buf, Int32(1))
        
        
        case .enabled:
            writeInt(&buf, Int32(2))
        
        
        case .deleting:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeAddressStatus_lift(_ buf: RustBuffer) throws -> AddressStatus {
    return try FfiConverterTypeAddressStatus.lift(buf)
}

public func FfiConverterTypeAddressStatus_lower(_ value: AddressStatus) -> RustBuffer {
    return FfiConverterTypeAddressStatus.lower(value)
}


extension AddressStatus: Sendable {} 
extension AddressStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AddressType : UInt8 {
    
    case original = 1
    case alias = 2
    case custom = 3
    case premium = 4
    case external = 5
}


public struct FfiConverterTypeAddressType: FfiConverterRustBuffer {
    typealias SwiftType = AddressType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .original
        
        case 2: return .alias
        
        case 3: return .custom
        
        case 4: return .premium
        
        case 5: return .external
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .original:
            writeInt(&buf, Int32(1))
        
        
        case .alias:
            writeInt(&buf, Int32(2))
        
        
        case .custom:
            writeInt(&buf, Int32(3))
        
        
        case .premium:
            writeInt(&buf, Int32(4))
        
        
        case .external:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeAddressType_lift(_ buf: RustBuffer) throws -> AddressType {
    return try FfiConverterTypeAddressType.lift(buf)
}

public func FfiConverterTypeAddressType_lower(_ value: AddressType) -> RustBuffer {
    return FfiConverterTypeAddressType.lower(value)
}


extension AddressType: Sendable {} 
extension AddressType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Disposition {
    
    case inline
    case attachment
}


public struct FfiConverterTypeDisposition: FfiConverterRustBuffer {
    typealias SwiftType = Disposition

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Disposition {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inline
        
        case 2: return .attachment
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Disposition, into buf: inout [UInt8]) {
        switch value {
        
        
        case .inline:
            writeInt(&buf, Int32(1))
        
        
        case .attachment:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeDisposition_lift(_ buf: RustBuffer) throws -> Disposition {
    return try FfiConverterTypeDisposition.lift(buf)
}

public func FfiConverterTypeDisposition_lower(_ value: Disposition) -> RustBuffer {
    return FfiConverterTypeDisposition.lower(value)
}


extension Disposition: Sendable {} 
extension Disposition: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LabelType : UInt8 {
    
    case label = 1
    case contactGroup = 2
    case folder = 3
    case system = 4
}


public struct FfiConverterTypeLabelType: FfiConverterRustBuffer {
    typealias SwiftType = LabelType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabelType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .label
        
        case 2: return .contactGroup
        
        case 3: return .folder
        
        case 4: return .system
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LabelType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .label:
            writeInt(&buf, Int32(1))
        
        
        case .contactGroup:
            writeInt(&buf, Int32(2))
        
        
        case .folder:
            writeInt(&buf, Int32(3))
        
        
        case .system:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeLabelType_lift(_ buf: RustBuffer) throws -> LabelType {
    return try FfiConverterTypeLabelType.lift(buf)
}

public func FfiConverterTypeLabelType_lower(_ value: LabelType) -> RustBuffer {
    return FfiConverterTypeLabelType.lower(value)
}


extension LabelType: Sendable {} 
extension LabelType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsAlmostAllMail : UInt8 {
    
    case allMail = 0
    case almostAllMail = 1
}


public struct FfiConverterTypeMailSettingsAlmostAllMail: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsAlmostAllMail

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsAlmostAllMail {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allMail
        
        case 2: return .almostAllMail
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsAlmostAllMail, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allMail:
            writeInt(&buf, Int32(1))
        
        
        case .almostAllMail:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsAlmostAllMail_lift(_ buf: RustBuffer) throws -> MailSettingsAlmostAllMail {
    return try FfiConverterTypeMailSettingsAlmostAllMail.lift(buf)
}

public func FfiConverterTypeMailSettingsAlmostAllMail_lower(_ value: MailSettingsAlmostAllMail) -> RustBuffer {
    return FfiConverterTypeMailSettingsAlmostAllMail.lower(value)
}


extension MailSettingsAlmostAllMail: Sendable {} 
extension MailSettingsAlmostAllMail: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsComposerDirection : UInt8 {
    
    case leftToRight = 0
    case rightToLeft = 1
}


public struct FfiConverterTypeMailSettingsComposerDirection: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsComposerDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsComposerDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .leftToRight
        
        case 2: return .rightToLeft
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsComposerDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .leftToRight:
            writeInt(&buf, Int32(1))
        
        
        case .rightToLeft:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsComposerDirection_lift(_ buf: RustBuffer) throws -> MailSettingsComposerDirection {
    return try FfiConverterTypeMailSettingsComposerDirection.lift(buf)
}

public func FfiConverterTypeMailSettingsComposerDirection_lower(_ value: MailSettingsComposerDirection) -> RustBuffer {
    return FfiConverterTypeMailSettingsComposerDirection.lower(value)
}


extension MailSettingsComposerDirection: Sendable {} 
extension MailSettingsComposerDirection: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsComposerMode : UInt8 {
    
    case normal = 0
    case maximized = 1
}


public struct FfiConverterTypeMailSettingsComposerMode: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsComposerMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsComposerMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .normal
        
        case 2: return .maximized
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsComposerMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .normal:
            writeInt(&buf, Int32(1))
        
        
        case .maximized:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsComposerMode_lift(_ buf: RustBuffer) throws -> MailSettingsComposerMode {
    return try FfiConverterTypeMailSettingsComposerMode.lift(buf)
}

public func FfiConverterTypeMailSettingsComposerMode_lower(_ value: MailSettingsComposerMode) -> RustBuffer {
    return FfiConverterTypeMailSettingsComposerMode.lower(value)
}


extension MailSettingsComposerMode: Sendable {} 
extension MailSettingsComposerMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsMessageButtons : UInt8 {
    
    case readFirst = 0
    case unreadFirst = 1
}


public struct FfiConverterTypeMailSettingsMessageButtons: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsMessageButtons

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsMessageButtons {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .readFirst
        
        case 2: return .unreadFirst
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsMessageButtons, into buf: inout [UInt8]) {
        switch value {
        
        
        case .readFirst:
            writeInt(&buf, Int32(1))
        
        
        case .unreadFirst:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsMessageButtons_lift(_ buf: RustBuffer) throws -> MailSettingsMessageButtons {
    return try FfiConverterTypeMailSettingsMessageButtons.lift(buf)
}

public func FfiConverterTypeMailSettingsMessageButtons_lower(_ value: MailSettingsMessageButtons) -> RustBuffer {
    return FfiConverterTypeMailSettingsMessageButtons.lower(value)
}


extension MailSettingsMessageButtons: Sendable {} 
extension MailSettingsMessageButtons: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsNextMessageOnMove : UInt8 {
    
    case disabledExplicit = 0
    case disabledImplicit = 1
    case enabledExplicit = 2
}


public struct FfiConverterTypeMailSettingsNextMessageOnMove: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsNextMessageOnMove

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsNextMessageOnMove {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disabledExplicit
        
        case 2: return .disabledImplicit
        
        case 3: return .enabledExplicit
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsNextMessageOnMove, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disabledExplicit:
            writeInt(&buf, Int32(1))
        
        
        case .disabledImplicit:
            writeInt(&buf, Int32(2))
        
        
        case .enabledExplicit:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMailSettingsNextMessageOnMove_lift(_ buf: RustBuffer) throws -> MailSettingsNextMessageOnMove {
    return try FfiConverterTypeMailSettingsNextMessageOnMove.lift(buf)
}

public func FfiConverterTypeMailSettingsNextMessageOnMove_lower(_ value: MailSettingsNextMessageOnMove) -> RustBuffer {
    return FfiConverterTypeMailSettingsNextMessageOnMove.lower(value)
}


extension MailSettingsNextMessageOnMove: Sendable {} 
extension MailSettingsNextMessageOnMove: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsPgpScheme : UInt8 {
    
    case inline = 8
    case mime = 16
}


public struct FfiConverterTypeMailSettingsPGPScheme: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsPgpScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsPgpScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inline
        
        case 2: return .mime
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsPgpScheme, into buf: inout [UInt8]) {
        switch value {
        
        
        case .inline:
            writeInt(&buf, Int32(1))
        
        
        case .mime:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsPGPScheme_lift(_ buf: RustBuffer) throws -> MailSettingsPgpScheme {
    return try FfiConverterTypeMailSettingsPGPScheme.lift(buf)
}

public func FfiConverterTypeMailSettingsPGPScheme_lower(_ value: MailSettingsPgpScheme) -> RustBuffer {
    return FfiConverterTypeMailSettingsPGPScheme.lower(value)
}


extension MailSettingsPgpScheme: Sendable {} 
extension MailSettingsPgpScheme: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsPmSignature : UInt8 {
    
    case disabled = 0
    case enabled = 1
    case enabledLocked = 2
}


public struct FfiConverterTypeMailSettingsPMSignature: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsPmSignature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsPmSignature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disabled
        
        case 2: return .enabled
        
        case 3: return .enabledLocked
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsPmSignature, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disabled:
            writeInt(&buf, Int32(1))
        
        
        case .enabled:
            writeInt(&buf, Int32(2))
        
        
        case .enabledLocked:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMailSettingsPMSignature_lift(_ buf: RustBuffer) throws -> MailSettingsPmSignature {
    return try FfiConverterTypeMailSettingsPMSignature.lift(buf)
}

public func FfiConverterTypeMailSettingsPMSignature_lower(_ value: MailSettingsPmSignature) -> RustBuffer {
    return FfiConverterTypeMailSettingsPMSignature.lower(value)
}


extension MailSettingsPmSignature: Sendable {} 
extension MailSettingsPmSignature: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsShowImages : UInt8 {
    
    case doNotAutoLoad = 0
    case autoLoadRemote = 1
    case autoLoadEmbedded = 2
    case autoLoadBoth = 3
}


public struct FfiConverterTypeMailSettingsShowImages: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsShowImages

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsShowImages {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .doNotAutoLoad
        
        case 2: return .autoLoadRemote
        
        case 3: return .autoLoadEmbedded
        
        case 4: return .autoLoadBoth
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsShowImages, into buf: inout [UInt8]) {
        switch value {
        
        
        case .doNotAutoLoad:
            writeInt(&buf, Int32(1))
        
        
        case .autoLoadRemote:
            writeInt(&buf, Int32(2))
        
        
        case .autoLoadEmbedded:
            writeInt(&buf, Int32(3))
        
        
        case .autoLoadBoth:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeMailSettingsShowImages_lift(_ buf: RustBuffer) throws -> MailSettingsShowImages {
    return try FfiConverterTypeMailSettingsShowImages.lift(buf)
}

public func FfiConverterTypeMailSettingsShowImages_lower(_ value: MailSettingsShowImages) -> RustBuffer {
    return FfiConverterTypeMailSettingsShowImages.lower(value)
}


extension MailSettingsShowImages: Sendable {} 
extension MailSettingsShowImages: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsShowMoved : UInt8 {
    
    case doNotKeep = 0
    case keepInDrafts = 1
    case keepInSent = 2
    case keepBoth = 3
}


public struct FfiConverterTypeMailSettingsShowMoved: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsShowMoved

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsShowMoved {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .doNotKeep
        
        case 2: return .keepInDrafts
        
        case 3: return .keepInSent
        
        case 4: return .keepBoth
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsShowMoved, into buf: inout [UInt8]) {
        switch value {
        
        
        case .doNotKeep:
            writeInt(&buf, Int32(1))
        
        
        case .keepInDrafts:
            writeInt(&buf, Int32(2))
        
        
        case .keepInSent:
            writeInt(&buf, Int32(3))
        
        
        case .keepBoth:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeMailSettingsShowMoved_lift(_ buf: RustBuffer) throws -> MailSettingsShowMoved {
    return try FfiConverterTypeMailSettingsShowMoved.lift(buf)
}

public func FfiConverterTypeMailSettingsShowMoved_lower(_ value: MailSettingsShowMoved) -> RustBuffer {
    return FfiConverterTypeMailSettingsShowMoved.lower(value)
}


extension MailSettingsShowMoved: Sendable {} 
extension MailSettingsShowMoved: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsSpamAction : UInt8 {
    
    case doNothing = 0
    case unsubscribeWithOneClick = 1
}


public struct FfiConverterTypeMailSettingsSpamAction: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsSpamAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsSpamAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .doNothing
        
        case 2: return .unsubscribeWithOneClick
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsSpamAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .doNothing:
            writeInt(&buf, Int32(1))
        
        
        case .unsubscribeWithOneClick:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsSpamAction_lift(_ buf: RustBuffer) throws -> MailSettingsSpamAction {
    return try FfiConverterTypeMailSettingsSpamAction.lift(buf)
}

public func FfiConverterTypeMailSettingsSpamAction_lower(_ value: MailSettingsSpamAction) -> RustBuffer {
    return FfiConverterTypeMailSettingsSpamAction.lower(value)
}


extension MailSettingsSpamAction: Sendable {} 
extension MailSettingsSpamAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsSwipeAction : UInt8 {
    
    case trash = 0
    case spam = 1
    case star = 2
    case archive = 3
    case markAsRead = 4
}


public struct FfiConverterTypeMailSettingsSwipeAction: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsSwipeAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsSwipeAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .trash
        
        case 2: return .spam
        
        case 3: return .star
        
        case 4: return .archive
        
        case 5: return .markAsRead
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsSwipeAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .trash:
            writeInt(&buf, Int32(1))
        
        
        case .spam:
            writeInt(&buf, Int32(2))
        
        
        case .star:
            writeInt(&buf, Int32(3))
        
        
        case .archive:
            writeInt(&buf, Int32(4))
        
        
        case .markAsRead:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeMailSettingsSwipeAction_lift(_ buf: RustBuffer) throws -> MailSettingsSwipeAction {
    return try FfiConverterTypeMailSettingsSwipeAction.lift(buf)
}

public func FfiConverterTypeMailSettingsSwipeAction_lower(_ value: MailSettingsSwipeAction) -> RustBuffer {
    return FfiConverterTypeMailSettingsSwipeAction.lower(value)
}


extension MailSettingsSwipeAction: Sendable {} 
extension MailSettingsSwipeAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsViewLayout : UInt8 {
    
    case column = 0
    case row = 1
}


public struct FfiConverterTypeMailSettingsViewLayout: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsViewLayout

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsViewLayout {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .column
        
        case 2: return .row
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsViewLayout, into buf: inout [UInt8]) {
        switch value {
        
        
        case .column:
            writeInt(&buf, Int32(1))
        
        
        case .row:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsViewLayout_lift(_ buf: RustBuffer) throws -> MailSettingsViewLayout {
    return try FfiConverterTypeMailSettingsViewLayout.lift(buf)
}

public func FfiConverterTypeMailSettingsViewLayout_lower(_ value: MailSettingsViewLayout) -> RustBuffer {
    return FfiConverterTypeMailSettingsViewLayout.lower(value)
}


extension MailSettingsViewLayout: Sendable {} 
extension MailSettingsViewLayout: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsViewMode : UInt8 {
    
    case conversations = 0
    case messages = 1
}


public struct FfiConverterTypeMailSettingsViewMode: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsViewMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsViewMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .conversations
        
        case 2: return .messages
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsViewMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .conversations:
            writeInt(&buf, Int32(1))
        
        
        case .messages:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsViewMode_lift(_ buf: RustBuffer) throws -> MailSettingsViewMode {
    return try FfiConverterTypeMailSettingsViewMode.lift(buf)
}

public func FfiConverterTypeMailSettingsViewMode_lower(_ value: MailSettingsViewMode) -> RustBuffer {
    return FfiConverterTypeMailSettingsViewMode.lower(value)
}


extension MailSettingsViewMode: Sendable {} 
extension MailSettingsViewMode: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMailSettingsMobileSettings: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsMobileSettings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMailSettingsMobileSettings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMailSettingsMobileSettings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMailSettingsNextMessageOnMove: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsNextMessageOnMove?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMailSettingsNextMessageOnMove.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMailSettingsNextMessageOnMove.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMailSettingsSpamAction: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsSpamAction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMailSettingsSpamAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMailSettingsSpamAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeExternalId: FfiConverterRustBuffer {
    typealias SwiftType = ExternalId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeExternalId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeExternalId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLabelId: FfiConverterRustBuffer {
    typealias SwiftType = LabelId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLabelId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLabelId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAttachmentMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [AttachmentMetadata]

    public static func write(_ value: [AttachmentMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttachmentMetadata.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttachmentMetadata] {
        let len: Int32 = try readInt(&buf)
        var seq = [AttachmentMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttachmentMetadata.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMessageAddress: FfiConverterRustBuffer {
    typealias SwiftType = [MessageAddress]

    public static func write(_ value: [MessageAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessageAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MessageAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [MessageAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessageAddress.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLabelId: FfiConverterRustBuffer {
    typealias SwiftType = [LabelId]

    public static func write(_ value: [LabelId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLabelId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LabelId] {
        let len: Int32 = try readInt(&buf)
        var seq = [LabelId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLabelId.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias AddressId = String
public struct FfiConverterTypeAddressId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: AddressId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> AddressId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: AddressId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeAddressId_lift(_ value: RustBuffer) throws -> AddressId {
    return try FfiConverterTypeAddressId.lift(value)
}

public func FfiConverterTypeAddressId_lower(_ value: AddressId) -> RustBuffer {
    return FfiConverterTypeAddressId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias AttachmentId = String
public struct FfiConverterTypeAttachmentId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: AttachmentId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> AttachmentId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: AttachmentId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeAttachmentId_lift(_ value: RustBuffer) throws -> AttachmentId {
    return try FfiConverterTypeAttachmentId.lift(value)
}

public func FfiConverterTypeAttachmentId_lower(_ value: AttachmentId) -> RustBuffer {
    return FfiConverterTypeAttachmentId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ConversationId = String
public struct FfiConverterTypeConversationId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversationId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ConversationId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ConversationId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ConversationId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeConversationId_lift(_ value: RustBuffer) throws -> ConversationId {
    return try FfiConverterTypeConversationId.lift(value)
}

public func FfiConverterTypeConversationId_lower(_ value: ConversationId) -> RustBuffer {
    return FfiConverterTypeConversationId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ExternalId = String
public struct FfiConverterTypeExternalId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ExternalId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ExternalId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ExternalId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeExternalId_lift(_ value: RustBuffer) throws -> ExternalId {
    return try FfiConverterTypeExternalId.lift(value)
}

public func FfiConverterTypeExternalId_lower(_ value: ExternalId) -> RustBuffer {
    return FfiConverterTypeExternalId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LabelId = String
public struct FfiConverterTypeLabelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: LabelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> LabelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: LabelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeLabelId_lift(_ value: RustBuffer) throws -> LabelId {
    return try FfiConverterTypeLabelId.lift(value)
}

public func FfiConverterTypeLabelId_lower(_ value: LabelId) -> RustBuffer {
    return FfiConverterTypeLabelId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias MessageId = String
public struct FfiConverterTypeMessageId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: MessageId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> MessageId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: MessageId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeMessageId_lift(_ value: RustBuffer) throws -> MessageId {
    return try FfiConverterTypeMessageId.lift(value)
}

public func FfiConverterTypeMessageId_lower(_ value: MessageId) -> RustBuffer {
    return FfiConverterTypeMessageId.lower(value)
}


private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_proton_api_mail_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all