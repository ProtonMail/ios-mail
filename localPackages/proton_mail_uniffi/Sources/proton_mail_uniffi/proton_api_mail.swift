// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(proton_mail_uniffi_ffi)
import proton_mail_uniffi_ffi
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_proton_api_mail_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_proton_api_mail_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public struct AttachmentMetadata {
    public var id: AttachmentId
    public var size: UInt64
    public var name: String
    public var mimeType: String
    public var disposition: Disposition

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: AttachmentId, size: UInt64, name: String, mimeType: String, disposition: Disposition) {
        self.id = id
        self.size = size
        self.name = name
        self.mimeType = mimeType
        self.disposition = disposition
    }
}


extension AttachmentMetadata: Sendable {} 
extension AttachmentMetadata: Equatable, Hashable {
    public static func ==(lhs: AttachmentMetadata, rhs: AttachmentMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.disposition != rhs.disposition {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(size)
        hasher.combine(name)
        hasher.combine(mimeType)
        hasher.combine(disposition)
    }
}


public struct FfiConverterTypeAttachmentMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentMetadata {
        return
            try AttachmentMetadata(
                id: FfiConverterTypeAttachmentId.read(from: &buf), 
                size: FfiConverterUInt64.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                mimeType: FfiConverterString.read(from: &buf), 
                disposition: FfiConverterTypeDisposition.read(from: &buf)
        )
    }

    public static func write(_ value: AttachmentMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeAttachmentId.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterTypeDisposition.write(value.disposition, into: &buf)
    }
}


public func FfiConverterTypeAttachmentMetadata_lift(_ buf: RustBuffer) throws -> AttachmentMetadata {
    return try FfiConverterTypeAttachmentMetadata.lift(buf)
}

public func FfiConverterTypeAttachmentMetadata_lower(_ value: AttachmentMetadata) -> RustBuffer {
    return FfiConverterTypeAttachmentMetadata.lower(value)
}


/**
 * Parameters to filter/search conversations with a given criteria.
 */
public struct ConversationFilter {
    /**
     * Conversation ids to filter on.
     */
    public var ids: [ConversationId]?
    /**
     * Keyword search of Subject field.
     */
    public var subject: String?
    /**
     * Keyword search of From field.
     */
    public var from: String?
    /**
     * Keyword search of To, CC and BCC fields.
     */
    public var recipients: [String]?
    /**
     * Keyword search of To, CC, BCC, From and Subject fields
     */
    public var keyword: String?
    /**
     * Address id to filter on.
     */
    public var addressId: AddressId?
    /**
     * Label id to filter on.
     */
    public var labelId: LabelId?
    /**
     * External id to filter on.
     */
    public var externalId: ExternalId?
    /**
     * Return only conversations older, in creation time (NOT timestamp), than `end_id` if timestamp = `end`
     */
    public var endId: ConversationId?
    /**
     * Return only conversations newer, in creation time (NOT timestamp), than `begin_id` if timestamp = `begin`
     */
    public var beginId: ConversationId?
    /**
     * UNIX timestamp to filter conversations earlier than timestamp
     */
    public var begin: UInt64?
    /**
     * UNIX timestamp to filter conversations later than timestamp
     */
    public var end: UInt64?
    /**
     * If true, return results in descending order rather than ascending.
     */
    public var desc: Bool?
    /**
     * If true, only return conversations which have attachments. If false, only return
     * conversations which have no attachments.
     */
    public var attachments: Bool?
    /**
     * If true, only return conversations which have unread messages. If false only return
     * conversations which have all messages read.
     */
    public var unread: Bool?
    /**
     * Sort the results by one of the sorting modes.
     */
    public var sort: MessageMetadataSortMode?
    /**
     * The number of conversations to return.
     */
    public var limit: UInt64?
    /**
     * If true automatically convert simple queries to wildcarded versions, such as `test` to `*test*`.
     */
    public var autoWildcard: Bool?
    /**
     * Page index
     */
    public var page: UInt64
    /**
     * Number of elements per page.
     */
    public var pageSize: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Conversation ids to filter on.
         */ids: [ConversationId]?, 
        /**
         * Keyword search of Subject field.
         */subject: String?, 
        /**
         * Keyword search of From field.
         */from: String?, 
        /**
         * Keyword search of To, CC and BCC fields.
         */recipients: [String]?, 
        /**
         * Keyword search of To, CC, BCC, From and Subject fields
         */keyword: String?, 
        /**
         * Address id to filter on.
         */addressId: AddressId?, 
        /**
         * Label id to filter on.
         */labelId: LabelId?, 
        /**
         * External id to filter on.
         */externalId: ExternalId?, 
        /**
         * Return only conversations older, in creation time (NOT timestamp), than `end_id` if timestamp = `end`
         */endId: ConversationId?, 
        /**
         * Return only conversations newer, in creation time (NOT timestamp), than `begin_id` if timestamp = `begin`
         */beginId: ConversationId?, 
        /**
         * UNIX timestamp to filter conversations earlier than timestamp
         */begin: UInt64?, 
        /**
         * UNIX timestamp to filter conversations later than timestamp
         */end: UInt64?, 
        /**
         * If true, return results in descending order rather than ascending.
         */desc: Bool?, 
        /**
         * If true, only return conversations which have attachments. If false, only return
         * conversations which have no attachments.
         */attachments: Bool?, 
        /**
         * If true, only return conversations which have unread messages. If false only return
         * conversations which have all messages read.
         */unread: Bool?, 
        /**
         * Sort the results by one of the sorting modes.
         */sort: MessageMetadataSortMode?, 
        /**
         * The number of conversations to return.
         */limit: UInt64?, 
        /**
         * If true automatically convert simple queries to wildcarded versions, such as `test` to `*test*`.
         */autoWildcard: Bool?, 
        /**
         * Page index
         */page: UInt64, 
        /**
         * Number of elements per page.
         */pageSize: UInt64) {
        self.ids = ids
        self.subject = subject
        self.from = from
        self.recipients = recipients
        self.keyword = keyword
        self.addressId = addressId
        self.labelId = labelId
        self.externalId = externalId
        self.endId = endId
        self.beginId = beginId
        self.begin = begin
        self.end = end
        self.desc = desc
        self.attachments = attachments
        self.unread = unread
        self.sort = sort
        self.limit = limit
        self.autoWildcard = autoWildcard
        self.page = page
        self.pageSize = pageSize
    }
}


extension ConversationFilter: Sendable {} 
extension ConversationFilter: Equatable, Hashable {
    public static func ==(lhs: ConversationFilter, rhs: ConversationFilter) -> Bool {
        if lhs.ids != rhs.ids {
            return false
        }
        if lhs.subject != rhs.subject {
            return false
        }
        if lhs.from != rhs.from {
            return false
        }
        if lhs.recipients != rhs.recipients {
            return false
        }
        if lhs.keyword != rhs.keyword {
            return false
        }
        if lhs.addressId != rhs.addressId {
            return false
        }
        if lhs.labelId != rhs.labelId {
            return false
        }
        if lhs.externalId != rhs.externalId {
            return false
        }
        if lhs.endId != rhs.endId {
            return false
        }
        if lhs.beginId != rhs.beginId {
            return false
        }
        if lhs.begin != rhs.begin {
            return false
        }
        if lhs.end != rhs.end {
            return false
        }
        if lhs.desc != rhs.desc {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.unread != rhs.unread {
            return false
        }
        if lhs.sort != rhs.sort {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.autoWildcard != rhs.autoWildcard {
            return false
        }
        if lhs.page != rhs.page {
            return false
        }
        if lhs.pageSize != rhs.pageSize {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ids)
        hasher.combine(subject)
        hasher.combine(from)
        hasher.combine(recipients)
        hasher.combine(keyword)
        hasher.combine(addressId)
        hasher.combine(labelId)
        hasher.combine(externalId)
        hasher.combine(endId)
        hasher.combine(beginId)
        hasher.combine(begin)
        hasher.combine(end)
        hasher.combine(desc)
        hasher.combine(attachments)
        hasher.combine(unread)
        hasher.combine(sort)
        hasher.combine(limit)
        hasher.combine(autoWildcard)
        hasher.combine(page)
        hasher.combine(pageSize)
    }
}


public struct FfiConverterTypeConversationFilter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversationFilter {
        return
            try ConversationFilter(
                ids: FfiConverterOptionSequenceTypeConversationId.read(from: &buf), 
                subject: FfiConverterOptionString.read(from: &buf), 
                from: FfiConverterOptionString.read(from: &buf), 
                recipients: FfiConverterOptionSequenceString.read(from: &buf), 
                keyword: FfiConverterOptionString.read(from: &buf), 
                addressId: FfiConverterOptionTypeAddressId.read(from: &buf), 
                labelId: FfiConverterOptionTypeLabelId.read(from: &buf), 
                externalId: FfiConverterOptionTypeExternalId.read(from: &buf), 
                endId: FfiConverterOptionTypeConversationId.read(from: &buf), 
                beginId: FfiConverterOptionTypeConversationId.read(from: &buf), 
                begin: FfiConverterOptionUInt64.read(from: &buf), 
                end: FfiConverterOptionUInt64.read(from: &buf), 
                desc: FfiConverterOptionBool.read(from: &buf), 
                attachments: FfiConverterOptionBool.read(from: &buf), 
                unread: FfiConverterOptionBool.read(from: &buf), 
                sort: FfiConverterOptionTypeMessageMetadataSortMode.read(from: &buf), 
                limit: FfiConverterOptionUInt64.read(from: &buf), 
                autoWildcard: FfiConverterOptionBool.read(from: &buf), 
                page: FfiConverterUInt64.read(from: &buf), 
                pageSize: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ConversationFilter, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeConversationId.write(value.ids, into: &buf)
        FfiConverterOptionString.write(value.subject, into: &buf)
        FfiConverterOptionString.write(value.from, into: &buf)
        FfiConverterOptionSequenceString.write(value.recipients, into: &buf)
        FfiConverterOptionString.write(value.keyword, into: &buf)
        FfiConverterOptionTypeAddressId.write(value.addressId, into: &buf)
        FfiConverterOptionTypeLabelId.write(value.labelId, into: &buf)
        FfiConverterOptionTypeExternalId.write(value.externalId, into: &buf)
        FfiConverterOptionTypeConversationId.write(value.endId, into: &buf)
        FfiConverterOptionTypeConversationId.write(value.beginId, into: &buf)
        FfiConverterOptionUInt64.write(value.begin, into: &buf)
        FfiConverterOptionUInt64.write(value.end, into: &buf)
        FfiConverterOptionBool.write(value.desc, into: &buf)
        FfiConverterOptionBool.write(value.attachments, into: &buf)
        FfiConverterOptionBool.write(value.unread, into: &buf)
        FfiConverterOptionTypeMessageMetadataSortMode.write(value.sort, into: &buf)
        FfiConverterOptionUInt64.write(value.limit, into: &buf)
        FfiConverterOptionBool.write(value.autoWildcard, into: &buf)
        FfiConverterUInt64.write(value.page, into: &buf)
        FfiConverterUInt64.write(value.pageSize, into: &buf)
    }
}


public func FfiConverterTypeConversationFilter_lift(_ buf: RustBuffer) throws -> ConversationFilter {
    return try FfiConverterTypeConversationFilter.lift(buf)
}

public func FfiConverterTypeConversationFilter_lower(_ value: ConversationFilter) -> RustBuffer {
    return FfiConverterTypeConversationFilter.lower(value)
}


public struct Label {
    public var id: LabelId
    public var parentId: LabelId?
    public var name: String
    public var path: String?
    public var color: String
    public var labelType: LabelType
    public var notify: Bool
    public var display: Bool
    public var sticky: Bool
    public var expanded: Bool
    public var order: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: LabelId, parentId: LabelId?, name: String, path: String?, color: String, labelType: LabelType, notify: Bool, display: Bool, sticky: Bool, expanded: Bool, order: UInt32) {
        self.id = id
        self.parentId = parentId
        self.name = name
        self.path = path
        self.color = color
        self.labelType = labelType
        self.notify = notify
        self.display = display
        self.sticky = sticky
        self.expanded = expanded
        self.order = order
    }
}


extension Label: Sendable {} 
extension Label: Equatable, Hashable {
    public static func ==(lhs: Label, rhs: Label) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.parentId != rhs.parentId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.labelType != rhs.labelType {
            return false
        }
        if lhs.notify != rhs.notify {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.sticky != rhs.sticky {
            return false
        }
        if lhs.expanded != rhs.expanded {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(parentId)
        hasher.combine(name)
        hasher.combine(path)
        hasher.combine(color)
        hasher.combine(labelType)
        hasher.combine(notify)
        hasher.combine(display)
        hasher.combine(sticky)
        hasher.combine(expanded)
        hasher.combine(order)
    }
}


public struct FfiConverterTypeLabel: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Label {
        return
            try Label(
                id: FfiConverterTypeLabelId.read(from: &buf), 
                parentId: FfiConverterOptionTypeLabelId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                path: FfiConverterOptionString.read(from: &buf), 
                color: FfiConverterString.read(from: &buf), 
                labelType: FfiConverterTypeLabelType.read(from: &buf), 
                notify: FfiConverterBool.read(from: &buf), 
                display: FfiConverterBool.read(from: &buf), 
                sticky: FfiConverterBool.read(from: &buf), 
                expanded: FfiConverterBool.read(from: &buf), 
                order: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Label, into buf: inout [UInt8]) {
        FfiConverterTypeLabelId.write(value.id, into: &buf)
        FfiConverterOptionTypeLabelId.write(value.parentId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.path, into: &buf)
        FfiConverterString.write(value.color, into: &buf)
        FfiConverterTypeLabelType.write(value.labelType, into: &buf)
        FfiConverterBool.write(value.notify, into: &buf)
        FfiConverterBool.write(value.display, into: &buf)
        FfiConverterBool.write(value.sticky, into: &buf)
        FfiConverterBool.write(value.expanded, into: &buf)
        FfiConverterUInt32.write(value.order, into: &buf)
    }
}


public func FfiConverterTypeLabel_lift(_ buf: RustBuffer) throws -> Label {
    return try FfiConverterTypeLabel.lift(buf)
}

public func FfiConverterTypeLabel_lower(_ value: Label) -> RustBuffer {
    return FfiConverterTypeLabel.lower(value)
}


public struct MailSettings {
    public var displayName: String
    public var signature: String
    public var theme: String
    public var autoSaveContacts: Bool
    public var composerMode: MailSettingsComposerMode
    public var messageButtons: MailSettingsMessageButtons
    public var showImages: MailSettingsShowImages
    public var showMoved: MailSettingsShowMoved
    public var autoDeleteSpamAndTrashDays: UInt32?
    public var almostAllMail: MailSettingsAlmostAllMail
    public var nextMessageOnMove: MailSettingsNextMessageOnMove?
    public var viewMode: MailSettingsViewMode
    public var viewLayout: MailSettingsViewLayout
    public var swipeLeft: MailSettingsSwipeAction
    public var swipeRight: MailSettingsSwipeAction
    public var shortcuts: Bool
    public var pmSignature: MailSettingsPmSignature
    public var pmSignatureReferralLink: Bool
    public var imageProxy: UInt32
    public var numMessagePerPage: UInt32
    public var draftMimeType: String
    public var receiveMimeType: String
    public var showMimeType: String
    public var enableFolderColor: Bool
    public var inheritParentFolderColor: Bool
    public var submissionAccess: Bool
    public var rightToLeft: MailSettingsComposerDirection
    public var attachPublicKey: Bool
    public var sign: Bool
    public var pgpScheme: MailSettingsPgpScheme
    public var promptPin: Bool
    public var stickyLabels: Bool
    public var confirmLink: Bool
    public var delaySendSeconds: UInt32
    public var fontFace: String?
    public var spamAction: MailSettingsSpamAction?
    public var blockSenderConfirmation: Bool?
    public var mobileSettings: MailSettingsMobileSettings?
    public var hideRemoteImages: Bool
    public var hideSenderImages: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: String, signature: String, theme: String, autoSaveContacts: Bool, composerMode: MailSettingsComposerMode, messageButtons: MailSettingsMessageButtons, showImages: MailSettingsShowImages, showMoved: MailSettingsShowMoved, autoDeleteSpamAndTrashDays: UInt32?, almostAllMail: MailSettingsAlmostAllMail, nextMessageOnMove: MailSettingsNextMessageOnMove?, viewMode: MailSettingsViewMode, viewLayout: MailSettingsViewLayout, swipeLeft: MailSettingsSwipeAction, swipeRight: MailSettingsSwipeAction, shortcuts: Bool, pmSignature: MailSettingsPmSignature, pmSignatureReferralLink: Bool, imageProxy: UInt32, numMessagePerPage: UInt32, draftMimeType: String, receiveMimeType: String, showMimeType: String, enableFolderColor: Bool, inheritParentFolderColor: Bool, submissionAccess: Bool, rightToLeft: MailSettingsComposerDirection, attachPublicKey: Bool, sign: Bool, pgpScheme: MailSettingsPgpScheme, promptPin: Bool, stickyLabels: Bool, confirmLink: Bool, delaySendSeconds: UInt32, fontFace: String?, spamAction: MailSettingsSpamAction?, blockSenderConfirmation: Bool?, mobileSettings: MailSettingsMobileSettings?, hideRemoteImages: Bool, hideSenderImages: Bool) {
        self.displayName = displayName
        self.signature = signature
        self.theme = theme
        self.autoSaveContacts = autoSaveContacts
        self.composerMode = composerMode
        self.messageButtons = messageButtons
        self.showImages = showImages
        self.showMoved = showMoved
        self.autoDeleteSpamAndTrashDays = autoDeleteSpamAndTrashDays
        self.almostAllMail = almostAllMail
        self.nextMessageOnMove = nextMessageOnMove
        self.viewMode = viewMode
        self.viewLayout = viewLayout
        self.swipeLeft = swipeLeft
        self.swipeRight = swipeRight
        self.shortcuts = shortcuts
        self.pmSignature = pmSignature
        self.pmSignatureReferralLink = pmSignatureReferralLink
        self.imageProxy = imageProxy
        self.numMessagePerPage = numMessagePerPage
        self.draftMimeType = draftMimeType
        self.receiveMimeType = receiveMimeType
        self.showMimeType = showMimeType
        self.enableFolderColor = enableFolderColor
        self.inheritParentFolderColor = inheritParentFolderColor
        self.submissionAccess = submissionAccess
        self.rightToLeft = rightToLeft
        self.attachPublicKey = attachPublicKey
        self.sign = sign
        self.pgpScheme = pgpScheme
        self.promptPin = promptPin
        self.stickyLabels = stickyLabels
        self.confirmLink = confirmLink
        self.delaySendSeconds = delaySendSeconds
        self.fontFace = fontFace
        self.spamAction = spamAction
        self.blockSenderConfirmation = blockSenderConfirmation
        self.mobileSettings = mobileSettings
        self.hideRemoteImages = hideRemoteImages
        self.hideSenderImages = hideSenderImages
    }
}


extension MailSettings: Sendable {} 
extension MailSettings: Equatable, Hashable {
    public static func ==(lhs: MailSettings, rhs: MailSettings) -> Bool {
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.theme != rhs.theme {
            return false
        }
        if lhs.autoSaveContacts != rhs.autoSaveContacts {
            return false
        }
        if lhs.composerMode != rhs.composerMode {
            return false
        }
        if lhs.messageButtons != rhs.messageButtons {
            return false
        }
        if lhs.showImages != rhs.showImages {
            return false
        }
        if lhs.showMoved != rhs.showMoved {
            return false
        }
        if lhs.autoDeleteSpamAndTrashDays != rhs.autoDeleteSpamAndTrashDays {
            return false
        }
        if lhs.almostAllMail != rhs.almostAllMail {
            return false
        }
        if lhs.nextMessageOnMove != rhs.nextMessageOnMove {
            return false
        }
        if lhs.viewMode != rhs.viewMode {
            return false
        }
        if lhs.viewLayout != rhs.viewLayout {
            return false
        }
        if lhs.swipeLeft != rhs.swipeLeft {
            return false
        }
        if lhs.swipeRight != rhs.swipeRight {
            return false
        }
        if lhs.shortcuts != rhs.shortcuts {
            return false
        }
        if lhs.pmSignature != rhs.pmSignature {
            return false
        }
        if lhs.pmSignatureReferralLink != rhs.pmSignatureReferralLink {
            return false
        }
        if lhs.imageProxy != rhs.imageProxy {
            return false
        }
        if lhs.numMessagePerPage != rhs.numMessagePerPage {
            return false
        }
        if lhs.draftMimeType != rhs.draftMimeType {
            return false
        }
        if lhs.receiveMimeType != rhs.receiveMimeType {
            return false
        }
        if lhs.showMimeType != rhs.showMimeType {
            return false
        }
        if lhs.enableFolderColor != rhs.enableFolderColor {
            return false
        }
        if lhs.inheritParentFolderColor != rhs.inheritParentFolderColor {
            return false
        }
        if lhs.submissionAccess != rhs.submissionAccess {
            return false
        }
        if lhs.rightToLeft != rhs.rightToLeft {
            return false
        }
        if lhs.attachPublicKey != rhs.attachPublicKey {
            return false
        }
        if lhs.sign != rhs.sign {
            return false
        }
        if lhs.pgpScheme != rhs.pgpScheme {
            return false
        }
        if lhs.promptPin != rhs.promptPin {
            return false
        }
        if lhs.stickyLabels != rhs.stickyLabels {
            return false
        }
        if lhs.confirmLink != rhs.confirmLink {
            return false
        }
        if lhs.delaySendSeconds != rhs.delaySendSeconds {
            return false
        }
        if lhs.fontFace != rhs.fontFace {
            return false
        }
        if lhs.spamAction != rhs.spamAction {
            return false
        }
        if lhs.blockSenderConfirmation != rhs.blockSenderConfirmation {
            return false
        }
        if lhs.mobileSettings != rhs.mobileSettings {
            return false
        }
        if lhs.hideRemoteImages != rhs.hideRemoteImages {
            return false
        }
        if lhs.hideSenderImages != rhs.hideSenderImages {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(displayName)
        hasher.combine(signature)
        hasher.combine(theme)
        hasher.combine(autoSaveContacts)
        hasher.combine(composerMode)
        hasher.combine(messageButtons)
        hasher.combine(showImages)
        hasher.combine(showMoved)
        hasher.combine(autoDeleteSpamAndTrashDays)
        hasher.combine(almostAllMail)
        hasher.combine(nextMessageOnMove)
        hasher.combine(viewMode)
        hasher.combine(viewLayout)
        hasher.combine(swipeLeft)
        hasher.combine(swipeRight)
        hasher.combine(shortcuts)
        hasher.combine(pmSignature)
        hasher.combine(pmSignatureReferralLink)
        hasher.combine(imageProxy)
        hasher.combine(numMessagePerPage)
        hasher.combine(draftMimeType)
        hasher.combine(receiveMimeType)
        hasher.combine(showMimeType)
        hasher.combine(enableFolderColor)
        hasher.combine(inheritParentFolderColor)
        hasher.combine(submissionAccess)
        hasher.combine(rightToLeft)
        hasher.combine(attachPublicKey)
        hasher.combine(sign)
        hasher.combine(pgpScheme)
        hasher.combine(promptPin)
        hasher.combine(stickyLabels)
        hasher.combine(confirmLink)
        hasher.combine(delaySendSeconds)
        hasher.combine(fontFace)
        hasher.combine(spamAction)
        hasher.combine(blockSenderConfirmation)
        hasher.combine(mobileSettings)
        hasher.combine(hideRemoteImages)
        hasher.combine(hideSenderImages)
    }
}


public struct FfiConverterTypeMailSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettings {
        return
            try MailSettings(
                displayName: FfiConverterString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf), 
                theme: FfiConverterString.read(from: &buf), 
                autoSaveContacts: FfiConverterBool.read(from: &buf), 
                composerMode: FfiConverterTypeMailSettingsComposerMode.read(from: &buf), 
                messageButtons: FfiConverterTypeMailSettingsMessageButtons.read(from: &buf), 
                showImages: FfiConverterTypeMailSettingsShowImages.read(from: &buf), 
                showMoved: FfiConverterTypeMailSettingsShowMoved.read(from: &buf), 
                autoDeleteSpamAndTrashDays: FfiConverterOptionUInt32.read(from: &buf), 
                almostAllMail: FfiConverterTypeMailSettingsAlmostAllMail.read(from: &buf), 
                nextMessageOnMove: FfiConverterOptionTypeMailSettingsNextMessageOnMove.read(from: &buf), 
                viewMode: FfiConverterTypeMailSettingsViewMode.read(from: &buf), 
                viewLayout: FfiConverterTypeMailSettingsViewLayout.read(from: &buf), 
                swipeLeft: FfiConverterTypeMailSettingsSwipeAction.read(from: &buf), 
                swipeRight: FfiConverterTypeMailSettingsSwipeAction.read(from: &buf), 
                shortcuts: FfiConverterBool.read(from: &buf), 
                pmSignature: FfiConverterTypeMailSettingsPMSignature.read(from: &buf), 
                pmSignatureReferralLink: FfiConverterBool.read(from: &buf), 
                imageProxy: FfiConverterUInt32.read(from: &buf), 
                numMessagePerPage: FfiConverterUInt32.read(from: &buf), 
                draftMimeType: FfiConverterString.read(from: &buf), 
                receiveMimeType: FfiConverterString.read(from: &buf), 
                showMimeType: FfiConverterString.read(from: &buf), 
                enableFolderColor: FfiConverterBool.read(from: &buf), 
                inheritParentFolderColor: FfiConverterBool.read(from: &buf), 
                submissionAccess: FfiConverterBool.read(from: &buf), 
                rightToLeft: FfiConverterTypeMailSettingsComposerDirection.read(from: &buf), 
                attachPublicKey: FfiConverterBool.read(from: &buf), 
                sign: FfiConverterBool.read(from: &buf), 
                pgpScheme: FfiConverterTypeMailSettingsPGPScheme.read(from: &buf), 
                promptPin: FfiConverterBool.read(from: &buf), 
                stickyLabels: FfiConverterBool.read(from: &buf), 
                confirmLink: FfiConverterBool.read(from: &buf), 
                delaySendSeconds: FfiConverterUInt32.read(from: &buf), 
                fontFace: FfiConverterOptionString.read(from: &buf), 
                spamAction: FfiConverterOptionTypeMailSettingsSpamAction.read(from: &buf), 
                blockSenderConfirmation: FfiConverterOptionBool.read(from: &buf), 
                mobileSettings: FfiConverterOptionTypeMailSettingsMobileSettings.read(from: &buf), 
                hideRemoteImages: FfiConverterBool.read(from: &buf), 
                hideSenderImages: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MailSettings, into buf: inout [UInt8]) {
        FfiConverterString.write(value.displayName, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
        FfiConverterString.write(value.theme, into: &buf)
        FfiConverterBool.write(value.autoSaveContacts, into: &buf)
        FfiConverterTypeMailSettingsComposerMode.write(value.composerMode, into: &buf)
        FfiConverterTypeMailSettingsMessageButtons.write(value.messageButtons, into: &buf)
        FfiConverterTypeMailSettingsShowImages.write(value.showImages, into: &buf)
        FfiConverterTypeMailSettingsShowMoved.write(value.showMoved, into: &buf)
        FfiConverterOptionUInt32.write(value.autoDeleteSpamAndTrashDays, into: &buf)
        FfiConverterTypeMailSettingsAlmostAllMail.write(value.almostAllMail, into: &buf)
        FfiConverterOptionTypeMailSettingsNextMessageOnMove.write(value.nextMessageOnMove, into: &buf)
        FfiConverterTypeMailSettingsViewMode.write(value.viewMode, into: &buf)
        FfiConverterTypeMailSettingsViewLayout.write(value.viewLayout, into: &buf)
        FfiConverterTypeMailSettingsSwipeAction.write(value.swipeLeft, into: &buf)
        FfiConverterTypeMailSettingsSwipeAction.write(value.swipeRight, into: &buf)
        FfiConverterBool.write(value.shortcuts, into: &buf)
        FfiConverterTypeMailSettingsPMSignature.write(value.pmSignature, into: &buf)
        FfiConverterBool.write(value.pmSignatureReferralLink, into: &buf)
        FfiConverterUInt32.write(value.imageProxy, into: &buf)
        FfiConverterUInt32.write(value.numMessagePerPage, into: &buf)
        FfiConverterString.write(value.draftMimeType, into: &buf)
        FfiConverterString.write(value.receiveMimeType, into: &buf)
        FfiConverterString.write(value.showMimeType, into: &buf)
        FfiConverterBool.write(value.enableFolderColor, into: &buf)
        FfiConverterBool.write(value.inheritParentFolderColor, into: &buf)
        FfiConverterBool.write(value.submissionAccess, into: &buf)
        FfiConverterTypeMailSettingsComposerDirection.write(value.rightToLeft, into: &buf)
        FfiConverterBool.write(value.attachPublicKey, into: &buf)
        FfiConverterBool.write(value.sign, into: &buf)
        FfiConverterTypeMailSettingsPGPScheme.write(value.pgpScheme, into: &buf)
        FfiConverterBool.write(value.promptPin, into: &buf)
        FfiConverterBool.write(value.stickyLabels, into: &buf)
        FfiConverterBool.write(value.confirmLink, into: &buf)
        FfiConverterUInt32.write(value.delaySendSeconds, into: &buf)
        FfiConverterOptionString.write(value.fontFace, into: &buf)
        FfiConverterOptionTypeMailSettingsSpamAction.write(value.spamAction, into: &buf)
        FfiConverterOptionBool.write(value.blockSenderConfirmation, into: &buf)
        FfiConverterOptionTypeMailSettingsMobileSettings.write(value.mobileSettings, into: &buf)
        FfiConverterBool.write(value.hideRemoteImages, into: &buf)
        FfiConverterBool.write(value.hideSenderImages, into: &buf)
    }
}


public func FfiConverterTypeMailSettings_lift(_ buf: RustBuffer) throws -> MailSettings {
    return try FfiConverterTypeMailSettings.lift(buf)
}

public func FfiConverterTypeMailSettings_lower(_ value: MailSettings) -> RustBuffer {
    return FfiConverterTypeMailSettings.lower(value)
}


public struct MailSettingsMobileSetting {
    public var isCustom: Bool
    public var actions: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isCustom: Bool, actions: [String]) {
        self.isCustom = isCustom
        self.actions = actions
    }
}


extension MailSettingsMobileSetting: Sendable {} 
extension MailSettingsMobileSetting: Equatable, Hashable {
    public static func ==(lhs: MailSettingsMobileSetting, rhs: MailSettingsMobileSetting) -> Bool {
        if lhs.isCustom != rhs.isCustom {
            return false
        }
        if lhs.actions != rhs.actions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCustom)
        hasher.combine(actions)
    }
}


public struct FfiConverterTypeMailSettingsMobileSetting: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsMobileSetting {
        return
            try MailSettingsMobileSetting(
                isCustom: FfiConverterBool.read(from: &buf), 
                actions: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: MailSettingsMobileSetting, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCustom, into: &buf)
        FfiConverterSequenceString.write(value.actions, into: &buf)
    }
}


public func FfiConverterTypeMailSettingsMobileSetting_lift(_ buf: RustBuffer) throws -> MailSettingsMobileSetting {
    return try FfiConverterTypeMailSettingsMobileSetting.lift(buf)
}

public func FfiConverterTypeMailSettingsMobileSetting_lower(_ value: MailSettingsMobileSetting) -> RustBuffer {
    return FfiConverterTypeMailSettingsMobileSetting.lower(value)
}


public struct MailSettingsMobileSettings {
    public var messageToolbar: MailSettingsMobileSetting
    public var conversationToolbar: MailSettingsMobileSetting
    public var listToolbar: MailSettingsMobileSetting

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(messageToolbar: MailSettingsMobileSetting, conversationToolbar: MailSettingsMobileSetting, listToolbar: MailSettingsMobileSetting) {
        self.messageToolbar = messageToolbar
        self.conversationToolbar = conversationToolbar
        self.listToolbar = listToolbar
    }
}


extension MailSettingsMobileSettings: Sendable {} 
extension MailSettingsMobileSettings: Equatable, Hashable {
    public static func ==(lhs: MailSettingsMobileSettings, rhs: MailSettingsMobileSettings) -> Bool {
        if lhs.messageToolbar != rhs.messageToolbar {
            return false
        }
        if lhs.conversationToolbar != rhs.conversationToolbar {
            return false
        }
        if lhs.listToolbar != rhs.listToolbar {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageToolbar)
        hasher.combine(conversationToolbar)
        hasher.combine(listToolbar)
    }
}


public struct FfiConverterTypeMailSettingsMobileSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsMobileSettings {
        return
            try MailSettingsMobileSettings(
                messageToolbar: FfiConverterTypeMailSettingsMobileSetting.read(from: &buf), 
                conversationToolbar: FfiConverterTypeMailSettingsMobileSetting.read(from: &buf), 
                listToolbar: FfiConverterTypeMailSettingsMobileSetting.read(from: &buf)
        )
    }

    public static func write(_ value: MailSettingsMobileSettings, into buf: inout [UInt8]) {
        FfiConverterTypeMailSettingsMobileSetting.write(value.messageToolbar, into: &buf)
        FfiConverterTypeMailSettingsMobileSetting.write(value.conversationToolbar, into: &buf)
        FfiConverterTypeMailSettingsMobileSetting.write(value.listToolbar, into: &buf)
    }
}


public func FfiConverterTypeMailSettingsMobileSettings_lift(_ buf: RustBuffer) throws -> MailSettingsMobileSettings {
    return try FfiConverterTypeMailSettingsMobileSettings.lift(buf)
}

public func FfiConverterTypeMailSettingsMobileSettings_lower(_ value: MailSettingsMobileSettings) -> RustBuffer {
    return FfiConverterTypeMailSettingsMobileSettings.lower(value)
}


public struct MessageAddress {
    public var address: String
    public var name: String
    public var isProton: Bool
    public var displaySenderImage: Bool
    public var isSimpleLogin: Bool
    public var bimiSelector: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, name: String, isProton: Bool, displaySenderImage: Bool, isSimpleLogin: Bool, bimiSelector: String?) {
        self.address = address
        self.name = name
        self.isProton = isProton
        self.displaySenderImage = displaySenderImage
        self.isSimpleLogin = isSimpleLogin
        self.bimiSelector = bimiSelector
    }
}


extension MessageAddress: Sendable {} 
extension MessageAddress: Equatable, Hashable {
    public static func ==(lhs: MessageAddress, rhs: MessageAddress) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.isProton != rhs.isProton {
            return false
        }
        if lhs.displaySenderImage != rhs.displaySenderImage {
            return false
        }
        if lhs.isSimpleLogin != rhs.isSimpleLogin {
            return false
        }
        if lhs.bimiSelector != rhs.bimiSelector {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(name)
        hasher.combine(isProton)
        hasher.combine(displaySenderImage)
        hasher.combine(isSimpleLogin)
        hasher.combine(bimiSelector)
    }
}


public struct FfiConverterTypeMessageAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageAddress {
        return
            try MessageAddress(
                address: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                isProton: FfiConverterBool.read(from: &buf), 
                displaySenderImage: FfiConverterBool.read(from: &buf), 
                isSimpleLogin: FfiConverterBool.read(from: &buf), 
                bimiSelector: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: MessageAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterBool.write(value.isProton, into: &buf)
        FfiConverterBool.write(value.displaySenderImage, into: &buf)
        FfiConverterBool.write(value.isSimpleLogin, into: &buf)
        FfiConverterOptionString.write(value.bimiSelector, into: &buf)
    }
}


public func FfiConverterTypeMessageAddress_lift(_ buf: RustBuffer) throws -> MessageAddress {
    return try FfiConverterTypeMessageAddress.lift(buf)
}

public func FfiConverterTypeMessageAddress_lower(_ value: MessageAddress) -> RustBuffer {
    return FfiConverterTypeMessageAddress.lower(value)
}


/**
 * Parameters to filter/search messages with a given criteria.
 */
public struct MessageMetadataFilter {
    /**
     * Page index.
     */
    public var page: UInt64
    /**
     * Number of elements per page.
     */
    public var pageSize: UInt64
    /**
     * The number of messages to return.
     */
    public var limit: UInt64?
    /**
     * Label ids to filter on.
     */
    public var labelId: [LabelId]?
    /**
     * Result sort mode.
     */
    public var sort: MessageMetadataSortMode?
    /**
     * If true sort results descending. If false, sort ascending.
     */
    public var desc: Bool?
    /**
     * UNIX timestamp to filter messages at or later than timestamp.
     */
    public var begin: UInt64?
    /**
     * UNIX timestamp to filter messages at or earlier than timestamp.
     */
    public var end: UInt64?
    /**
     * Return only messages newer, in creation time (NOT timestamp), than `begin_id`.
     */
    public var beginId: MessageId?
    /**
     * Return only messages older, in creation time (NOT timestamp), than `end_id`.
     */
    public var endId: MessageId?
    /**
     * Keyword search of To, CC, BCC, From and Subject fields.
     */
    public var keyword: String?
    /**
     * Keyword search of To, CC and BCC fields.
     */
    public var recipients: [String]?
    /**
     * Keyword search of To field.
     */
    public var to: String?
    /**
     * Keyword search of CC field.
     */
    public var cc: String?
    /**
     * Keyword search of BCC field.
     */
    public var bcc: String?
    /**
     * Keyword search From field.
     */
    public var from: String?
    /**
     * Keyword search Subject field.
     */
    public var subject: String?
    /**
     * If true return only messages which have attachments. If false return only messages which
     * have no attachments.
     */
    public var attachments: Bool?
    /**
     * If true return only messages which are unread. If false return only messages which are read.
     */
    public var unread: Bool?
    /**
     * Filter messages by `conversation_id`.
     */
    public var conversationId: ConversationId?
    /**
     * Filter on address id.
     */
    public var addressId: AddressId?
    /**
     * Filter on external id.
     */
    public var externalId: ExternalId?
    /**
     * Filter on the given message ids.
     */
    public var ids: [MessageId]?
    /**
     * If true automatically convert simple queries to wildcarded versions, such as `test` to `*test*`.
     */
    public var autoWildcard: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Page index.
         */page: UInt64, 
        /**
         * Number of elements per page.
         */pageSize: UInt64, 
        /**
         * The number of messages to return.
         */limit: UInt64?, 
        /**
         * Label ids to filter on.
         */labelId: [LabelId]?, 
        /**
         * Result sort mode.
         */sort: MessageMetadataSortMode?, 
        /**
         * If true sort results descending. If false, sort ascending.
         */desc: Bool?, 
        /**
         * UNIX timestamp to filter messages at or later than timestamp.
         */begin: UInt64?, 
        /**
         * UNIX timestamp to filter messages at or earlier than timestamp.
         */end: UInt64?, 
        /**
         * Return only messages newer, in creation time (NOT timestamp), than `begin_id`.
         */beginId: MessageId?, 
        /**
         * Return only messages older, in creation time (NOT timestamp), than `end_id`.
         */endId: MessageId?, 
        /**
         * Keyword search of To, CC, BCC, From and Subject fields.
         */keyword: String?, 
        /**
         * Keyword search of To, CC and BCC fields.
         */recipients: [String]?, 
        /**
         * Keyword search of To field.
         */to: String?, 
        /**
         * Keyword search of CC field.
         */cc: String?, 
        /**
         * Keyword search of BCC field.
         */bcc: String?, 
        /**
         * Keyword search From field.
         */from: String?, 
        /**
         * Keyword search Subject field.
         */subject: String?, 
        /**
         * If true return only messages which have attachments. If false return only messages which
         * have no attachments.
         */attachments: Bool?, 
        /**
         * If true return only messages which are unread. If false return only messages which are read.
         */unread: Bool?, 
        /**
         * Filter messages by `conversation_id`.
         */conversationId: ConversationId?, 
        /**
         * Filter on address id.
         */addressId: AddressId?, 
        /**
         * Filter on external id.
         */externalId: ExternalId?, 
        /**
         * Filter on the given message ids.
         */ids: [MessageId]?, 
        /**
         * If true automatically convert simple queries to wildcarded versions, such as `test` to `*test*`.
         */autoWildcard: Bool?) {
        self.page = page
        self.pageSize = pageSize
        self.limit = limit
        self.labelId = labelId
        self.sort = sort
        self.desc = desc
        self.begin = begin
        self.end = end
        self.beginId = beginId
        self.endId = endId
        self.keyword = keyword
        self.recipients = recipients
        self.to = to
        self.cc = cc
        self.bcc = bcc
        self.from = from
        self.subject = subject
        self.attachments = attachments
        self.unread = unread
        self.conversationId = conversationId
        self.addressId = addressId
        self.externalId = externalId
        self.ids = ids
        self.autoWildcard = autoWildcard
    }
}


extension MessageMetadataFilter: Sendable {} 
extension MessageMetadataFilter: Equatable, Hashable {
    public static func ==(lhs: MessageMetadataFilter, rhs: MessageMetadataFilter) -> Bool {
        if lhs.page != rhs.page {
            return false
        }
        if lhs.pageSize != rhs.pageSize {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.labelId != rhs.labelId {
            return false
        }
        if lhs.sort != rhs.sort {
            return false
        }
        if lhs.desc != rhs.desc {
            return false
        }
        if lhs.begin != rhs.begin {
            return false
        }
        if lhs.end != rhs.end {
            return false
        }
        if lhs.beginId != rhs.beginId {
            return false
        }
        if lhs.endId != rhs.endId {
            return false
        }
        if lhs.keyword != rhs.keyword {
            return false
        }
        if lhs.recipients != rhs.recipients {
            return false
        }
        if lhs.to != rhs.to {
            return false
        }
        if lhs.cc != rhs.cc {
            return false
        }
        if lhs.bcc != rhs.bcc {
            return false
        }
        if lhs.from != rhs.from {
            return false
        }
        if lhs.subject != rhs.subject {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.unread != rhs.unread {
            return false
        }
        if lhs.conversationId != rhs.conversationId {
            return false
        }
        if lhs.addressId != rhs.addressId {
            return false
        }
        if lhs.externalId != rhs.externalId {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        if lhs.autoWildcard != rhs.autoWildcard {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(page)
        hasher.combine(pageSize)
        hasher.combine(limit)
        hasher.combine(labelId)
        hasher.combine(sort)
        hasher.combine(desc)
        hasher.combine(begin)
        hasher.combine(end)
        hasher.combine(beginId)
        hasher.combine(endId)
        hasher.combine(keyword)
        hasher.combine(recipients)
        hasher.combine(to)
        hasher.combine(cc)
        hasher.combine(bcc)
        hasher.combine(from)
        hasher.combine(subject)
        hasher.combine(attachments)
        hasher.combine(unread)
        hasher.combine(conversationId)
        hasher.combine(addressId)
        hasher.combine(externalId)
        hasher.combine(ids)
        hasher.combine(autoWildcard)
    }
}


public struct FfiConverterTypeMessageMetadataFilter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageMetadataFilter {
        return
            try MessageMetadataFilter(
                page: FfiConverterUInt64.read(from: &buf), 
                pageSize: FfiConverterUInt64.read(from: &buf), 
                limit: FfiConverterOptionUInt64.read(from: &buf), 
                labelId: FfiConverterOptionSequenceTypeLabelId.read(from: &buf), 
                sort: FfiConverterOptionTypeMessageMetadataSortMode.read(from: &buf), 
                desc: FfiConverterOptionBool.read(from: &buf), 
                begin: FfiConverterOptionUInt64.read(from: &buf), 
                end: FfiConverterOptionUInt64.read(from: &buf), 
                beginId: FfiConverterOptionTypeMessageId.read(from: &buf), 
                endId: FfiConverterOptionTypeMessageId.read(from: &buf), 
                keyword: FfiConverterOptionString.read(from: &buf), 
                recipients: FfiConverterOptionSequenceString.read(from: &buf), 
                to: FfiConverterOptionString.read(from: &buf), 
                cc: FfiConverterOptionString.read(from: &buf), 
                bcc: FfiConverterOptionString.read(from: &buf), 
                from: FfiConverterOptionString.read(from: &buf), 
                subject: FfiConverterOptionString.read(from: &buf), 
                attachments: FfiConverterOptionBool.read(from: &buf), 
                unread: FfiConverterOptionBool.read(from: &buf), 
                conversationId: FfiConverterOptionTypeConversationId.read(from: &buf), 
                addressId: FfiConverterOptionTypeAddressId.read(from: &buf), 
                externalId: FfiConverterOptionTypeExternalId.read(from: &buf), 
                ids: FfiConverterOptionSequenceTypeMessageId.read(from: &buf), 
                autoWildcard: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: MessageMetadataFilter, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.page, into: &buf)
        FfiConverterUInt64.write(value.pageSize, into: &buf)
        FfiConverterOptionUInt64.write(value.limit, into: &buf)
        FfiConverterOptionSequenceTypeLabelId.write(value.labelId, into: &buf)
        FfiConverterOptionTypeMessageMetadataSortMode.write(value.sort, into: &buf)
        FfiConverterOptionBool.write(value.desc, into: &buf)
        FfiConverterOptionUInt64.write(value.begin, into: &buf)
        FfiConverterOptionUInt64.write(value.end, into: &buf)
        FfiConverterOptionTypeMessageId.write(value.beginId, into: &buf)
        FfiConverterOptionTypeMessageId.write(value.endId, into: &buf)
        FfiConverterOptionString.write(value.keyword, into: &buf)
        FfiConverterOptionSequenceString.write(value.recipients, into: &buf)
        FfiConverterOptionString.write(value.to, into: &buf)
        FfiConverterOptionString.write(value.cc, into: &buf)
        FfiConverterOptionString.write(value.bcc, into: &buf)
        FfiConverterOptionString.write(value.from, into: &buf)
        FfiConverterOptionString.write(value.subject, into: &buf)
        FfiConverterOptionBool.write(value.attachments, into: &buf)
        FfiConverterOptionBool.write(value.unread, into: &buf)
        FfiConverterOptionTypeConversationId.write(value.conversationId, into: &buf)
        FfiConverterOptionTypeAddressId.write(value.addressId, into: &buf)
        FfiConverterOptionTypeExternalId.write(value.externalId, into: &buf)
        FfiConverterOptionSequenceTypeMessageId.write(value.ids, into: &buf)
        FfiConverterOptionBool.write(value.autoWildcard, into: &buf)
    }
}


public func FfiConverterTypeMessageMetadataFilter_lift(_ buf: RustBuffer) throws -> MessageMetadataFilter {
    return try FfiConverterTypeMessageMetadataFilter.lift(buf)
}

public func FfiConverterTypeMessageMetadataFilter_lower(_ value: MessageMetadataFilter) -> RustBuffer {
    return FfiConverterTypeMessageMetadataFilter.lower(value)
}


public struct UniffiGenCustomTypes {
    public var cid: ConversationId
    public var mid: MessageId
    public var eid: ExternalId
    public var mimeType: MimeType
    public var msgFlags: MessageFlags

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cid: ConversationId, mid: MessageId, eid: ExternalId, mimeType: MimeType, msgFlags: MessageFlags) {
        self.cid = cid
        self.mid = mid
        self.eid = eid
        self.mimeType = mimeType
        self.msgFlags = msgFlags
    }
}


extension UniffiGenCustomTypes: Sendable {} 
extension UniffiGenCustomTypes: Equatable, Hashable {
    public static func ==(lhs: UniffiGenCustomTypes, rhs: UniffiGenCustomTypes) -> Bool {
        if lhs.cid != rhs.cid {
            return false
        }
        if lhs.mid != rhs.mid {
            return false
        }
        if lhs.eid != rhs.eid {
            return false
        }
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.msgFlags != rhs.msgFlags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cid)
        hasher.combine(mid)
        hasher.combine(eid)
        hasher.combine(mimeType)
        hasher.combine(msgFlags)
    }
}


public struct FfiConverterTypeUniffiGenCustomTypes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiGenCustomTypes {
        return
            try UniffiGenCustomTypes(
                cid: FfiConverterTypeConversationId.read(from: &buf), 
                mid: FfiConverterTypeMessageId.read(from: &buf), 
                eid: FfiConverterTypeExternalId.read(from: &buf), 
                mimeType: FfiConverterTypeMimeType.read(from: &buf), 
                msgFlags: FfiConverterTypeMessageFlags.read(from: &buf)
        )
    }

    public static func write(_ value: UniffiGenCustomTypes, into buf: inout [UInt8]) {
        FfiConverterTypeConversationId.write(value.cid, into: &buf)
        FfiConverterTypeMessageId.write(value.mid, into: &buf)
        FfiConverterTypeExternalId.write(value.eid, into: &buf)
        FfiConverterTypeMimeType.write(value.mimeType, into: &buf)
        FfiConverterTypeMessageFlags.write(value.msgFlags, into: &buf)
    }
}


public func FfiConverterTypeUniffiGenCustomTypes_lift(_ buf: RustBuffer) throws -> UniffiGenCustomTypes {
    return try FfiConverterTypeUniffiGenCustomTypes.lift(buf)
}

public func FfiConverterTypeUniffiGenCustomTypes_lower(_ value: UniffiGenCustomTypes) -> RustBuffer {
    return FfiConverterTypeUniffiGenCustomTypes.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Disposition {
    
    case inline
    case attachment
}


public struct FfiConverterTypeDisposition: FfiConverterRustBuffer {
    typealias SwiftType = Disposition

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Disposition {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inline
        
        case 2: return .attachment
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Disposition, into buf: inout [UInt8]) {
        switch value {
        
        
        case .inline:
            writeInt(&buf, Int32(1))
        
        
        case .attachment:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeDisposition_lift(_ buf: RustBuffer) throws -> Disposition {
    return try FfiConverterTypeDisposition.lift(buf)
}

public func FfiConverterTypeDisposition_lower(_ value: Disposition) -> RustBuffer {
    return FfiConverterTypeDisposition.lower(value)
}


extension Disposition: Sendable {} 
extension Disposition: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LabelType : UInt8 {
    
    case label = 1
    case contactGroup = 2
    case folder = 3
    case system = 4
}


public struct FfiConverterTypeLabelType: FfiConverterRustBuffer {
    typealias SwiftType = LabelType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabelType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .label
        
        case 2: return .contactGroup
        
        case 3: return .folder
        
        case 4: return .system
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LabelType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .label:
            writeInt(&buf, Int32(1))
        
        
        case .contactGroup:
            writeInt(&buf, Int32(2))
        
        
        case .folder:
            writeInt(&buf, Int32(3))
        
        
        case .system:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeLabelType_lift(_ buf: RustBuffer) throws -> LabelType {
    return try FfiConverterTypeLabelType.lift(buf)
}

public func FfiConverterTypeLabelType_lower(_ value: LabelType) -> RustBuffer {
    return FfiConverterTypeLabelType.lower(value)
}


extension LabelType: Sendable {} 
extension LabelType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsAlmostAllMail : UInt8 {
    
    case allMail = 0
    case almostAllMail = 1
}


public struct FfiConverterTypeMailSettingsAlmostAllMail: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsAlmostAllMail

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsAlmostAllMail {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allMail
        
        case 2: return .almostAllMail
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsAlmostAllMail, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allMail:
            writeInt(&buf, Int32(1))
        
        
        case .almostAllMail:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsAlmostAllMail_lift(_ buf: RustBuffer) throws -> MailSettingsAlmostAllMail {
    return try FfiConverterTypeMailSettingsAlmostAllMail.lift(buf)
}

public func FfiConverterTypeMailSettingsAlmostAllMail_lower(_ value: MailSettingsAlmostAllMail) -> RustBuffer {
    return FfiConverterTypeMailSettingsAlmostAllMail.lower(value)
}


extension MailSettingsAlmostAllMail: Sendable {} 
extension MailSettingsAlmostAllMail: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsComposerDirection : UInt8 {
    
    case leftToRight = 0
    case rightToLeft = 1
}


public struct FfiConverterTypeMailSettingsComposerDirection: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsComposerDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsComposerDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .leftToRight
        
        case 2: return .rightToLeft
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsComposerDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .leftToRight:
            writeInt(&buf, Int32(1))
        
        
        case .rightToLeft:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsComposerDirection_lift(_ buf: RustBuffer) throws -> MailSettingsComposerDirection {
    return try FfiConverterTypeMailSettingsComposerDirection.lift(buf)
}

public func FfiConverterTypeMailSettingsComposerDirection_lower(_ value: MailSettingsComposerDirection) -> RustBuffer {
    return FfiConverterTypeMailSettingsComposerDirection.lower(value)
}


extension MailSettingsComposerDirection: Sendable {} 
extension MailSettingsComposerDirection: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsComposerMode : UInt8 {
    
    case normal = 0
    case maximized = 1
}


public struct FfiConverterTypeMailSettingsComposerMode: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsComposerMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsComposerMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .normal
        
        case 2: return .maximized
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsComposerMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .normal:
            writeInt(&buf, Int32(1))
        
        
        case .maximized:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsComposerMode_lift(_ buf: RustBuffer) throws -> MailSettingsComposerMode {
    return try FfiConverterTypeMailSettingsComposerMode.lift(buf)
}

public func FfiConverterTypeMailSettingsComposerMode_lower(_ value: MailSettingsComposerMode) -> RustBuffer {
    return FfiConverterTypeMailSettingsComposerMode.lower(value)
}


extension MailSettingsComposerMode: Sendable {} 
extension MailSettingsComposerMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsMessageButtons : UInt8 {
    
    case readFirst = 0
    case unreadFirst = 1
}


public struct FfiConverterTypeMailSettingsMessageButtons: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsMessageButtons

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsMessageButtons {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .readFirst
        
        case 2: return .unreadFirst
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsMessageButtons, into buf: inout [UInt8]) {
        switch value {
        
        
        case .readFirst:
            writeInt(&buf, Int32(1))
        
        
        case .unreadFirst:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsMessageButtons_lift(_ buf: RustBuffer) throws -> MailSettingsMessageButtons {
    return try FfiConverterTypeMailSettingsMessageButtons.lift(buf)
}

public func FfiConverterTypeMailSettingsMessageButtons_lower(_ value: MailSettingsMessageButtons) -> RustBuffer {
    return FfiConverterTypeMailSettingsMessageButtons.lower(value)
}


extension MailSettingsMessageButtons: Sendable {} 
extension MailSettingsMessageButtons: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsNextMessageOnMove : UInt8 {
    
    case disabledExplicit = 0
    case disabledImplicit = 1
    case enabledExplicit = 2
}


public struct FfiConverterTypeMailSettingsNextMessageOnMove: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsNextMessageOnMove

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsNextMessageOnMove {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disabledExplicit
        
        case 2: return .disabledImplicit
        
        case 3: return .enabledExplicit
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsNextMessageOnMove, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disabledExplicit:
            writeInt(&buf, Int32(1))
        
        
        case .disabledImplicit:
            writeInt(&buf, Int32(2))
        
        
        case .enabledExplicit:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMailSettingsNextMessageOnMove_lift(_ buf: RustBuffer) throws -> MailSettingsNextMessageOnMove {
    return try FfiConverterTypeMailSettingsNextMessageOnMove.lift(buf)
}

public func FfiConverterTypeMailSettingsNextMessageOnMove_lower(_ value: MailSettingsNextMessageOnMove) -> RustBuffer {
    return FfiConverterTypeMailSettingsNextMessageOnMove.lower(value)
}


extension MailSettingsNextMessageOnMove: Sendable {} 
extension MailSettingsNextMessageOnMove: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsPgpScheme : UInt8 {
    
    case inline = 8
    case mime = 16
}


public struct FfiConverterTypeMailSettingsPGPScheme: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsPgpScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsPgpScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inline
        
        case 2: return .mime
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsPgpScheme, into buf: inout [UInt8]) {
        switch value {
        
        
        case .inline:
            writeInt(&buf, Int32(1))
        
        
        case .mime:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsPGPScheme_lift(_ buf: RustBuffer) throws -> MailSettingsPgpScheme {
    return try FfiConverterTypeMailSettingsPGPScheme.lift(buf)
}

public func FfiConverterTypeMailSettingsPGPScheme_lower(_ value: MailSettingsPgpScheme) -> RustBuffer {
    return FfiConverterTypeMailSettingsPGPScheme.lower(value)
}


extension MailSettingsPgpScheme: Sendable {} 
extension MailSettingsPgpScheme: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsPmSignature : UInt8 {
    
    case disabled = 0
    case enabled = 1
    case enabledLocked = 2
}


public struct FfiConverterTypeMailSettingsPMSignature: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsPmSignature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsPmSignature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disabled
        
        case 2: return .enabled
        
        case 3: return .enabledLocked
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsPmSignature, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disabled:
            writeInt(&buf, Int32(1))
        
        
        case .enabled:
            writeInt(&buf, Int32(2))
        
        
        case .enabledLocked:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMailSettingsPMSignature_lift(_ buf: RustBuffer) throws -> MailSettingsPmSignature {
    return try FfiConverterTypeMailSettingsPMSignature.lift(buf)
}

public func FfiConverterTypeMailSettingsPMSignature_lower(_ value: MailSettingsPmSignature) -> RustBuffer {
    return FfiConverterTypeMailSettingsPMSignature.lower(value)
}


extension MailSettingsPmSignature: Sendable {} 
extension MailSettingsPmSignature: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsShowImages : UInt8 {
    
    case doNotAutoLoad = 0
    case autoLoadRemote = 1
    case autoLoadEmbedded = 2
    case autoLoadBoth = 3
}


public struct FfiConverterTypeMailSettingsShowImages: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsShowImages

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsShowImages {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .doNotAutoLoad
        
        case 2: return .autoLoadRemote
        
        case 3: return .autoLoadEmbedded
        
        case 4: return .autoLoadBoth
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsShowImages, into buf: inout [UInt8]) {
        switch value {
        
        
        case .doNotAutoLoad:
            writeInt(&buf, Int32(1))
        
        
        case .autoLoadRemote:
            writeInt(&buf, Int32(2))
        
        
        case .autoLoadEmbedded:
            writeInt(&buf, Int32(3))
        
        
        case .autoLoadBoth:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeMailSettingsShowImages_lift(_ buf: RustBuffer) throws -> MailSettingsShowImages {
    return try FfiConverterTypeMailSettingsShowImages.lift(buf)
}

public func FfiConverterTypeMailSettingsShowImages_lower(_ value: MailSettingsShowImages) -> RustBuffer {
    return FfiConverterTypeMailSettingsShowImages.lower(value)
}


extension MailSettingsShowImages: Sendable {} 
extension MailSettingsShowImages: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsShowMoved : UInt8 {
    
    case doNotKeep = 0
    case keepInDrafts = 1
    case keepInSent = 2
    case keepBoth = 3
}


public struct FfiConverterTypeMailSettingsShowMoved: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsShowMoved

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsShowMoved {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .doNotKeep
        
        case 2: return .keepInDrafts
        
        case 3: return .keepInSent
        
        case 4: return .keepBoth
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsShowMoved, into buf: inout [UInt8]) {
        switch value {
        
        
        case .doNotKeep:
            writeInt(&buf, Int32(1))
        
        
        case .keepInDrafts:
            writeInt(&buf, Int32(2))
        
        
        case .keepInSent:
            writeInt(&buf, Int32(3))
        
        
        case .keepBoth:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeMailSettingsShowMoved_lift(_ buf: RustBuffer) throws -> MailSettingsShowMoved {
    return try FfiConverterTypeMailSettingsShowMoved.lift(buf)
}

public func FfiConverterTypeMailSettingsShowMoved_lower(_ value: MailSettingsShowMoved) -> RustBuffer {
    return FfiConverterTypeMailSettingsShowMoved.lower(value)
}


extension MailSettingsShowMoved: Sendable {} 
extension MailSettingsShowMoved: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsSpamAction : UInt8 {
    
    case doNothing = 0
    case unsubscribeWithOneClick = 1
}


public struct FfiConverterTypeMailSettingsSpamAction: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsSpamAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsSpamAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .doNothing
        
        case 2: return .unsubscribeWithOneClick
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsSpamAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .doNothing:
            writeInt(&buf, Int32(1))
        
        
        case .unsubscribeWithOneClick:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsSpamAction_lift(_ buf: RustBuffer) throws -> MailSettingsSpamAction {
    return try FfiConverterTypeMailSettingsSpamAction.lift(buf)
}

public func FfiConverterTypeMailSettingsSpamAction_lower(_ value: MailSettingsSpamAction) -> RustBuffer {
    return FfiConverterTypeMailSettingsSpamAction.lower(value)
}


extension MailSettingsSpamAction: Sendable {} 
extension MailSettingsSpamAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsSwipeAction : UInt8 {
    
    case trash = 0
    case spam = 1
    case star = 2
    case archive = 3
    case markAsRead = 4
}


public struct FfiConverterTypeMailSettingsSwipeAction: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsSwipeAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsSwipeAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .trash
        
        case 2: return .spam
        
        case 3: return .star
        
        case 4: return .archive
        
        case 5: return .markAsRead
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsSwipeAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .trash:
            writeInt(&buf, Int32(1))
        
        
        case .spam:
            writeInt(&buf, Int32(2))
        
        
        case .star:
            writeInt(&buf, Int32(3))
        
        
        case .archive:
            writeInt(&buf, Int32(4))
        
        
        case .markAsRead:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeMailSettingsSwipeAction_lift(_ buf: RustBuffer) throws -> MailSettingsSwipeAction {
    return try FfiConverterTypeMailSettingsSwipeAction.lift(buf)
}

public func FfiConverterTypeMailSettingsSwipeAction_lower(_ value: MailSettingsSwipeAction) -> RustBuffer {
    return FfiConverterTypeMailSettingsSwipeAction.lower(value)
}


extension MailSettingsSwipeAction: Sendable {} 
extension MailSettingsSwipeAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsViewLayout : UInt8 {
    
    case column = 0
    case row = 1
}


public struct FfiConverterTypeMailSettingsViewLayout: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsViewLayout

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsViewLayout {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .column
        
        case 2: return .row
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsViewLayout, into buf: inout [UInt8]) {
        switch value {
        
        
        case .column:
            writeInt(&buf, Int32(1))
        
        
        case .row:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsViewLayout_lift(_ buf: RustBuffer) throws -> MailSettingsViewLayout {
    return try FfiConverterTypeMailSettingsViewLayout.lift(buf)
}

public func FfiConverterTypeMailSettingsViewLayout_lower(_ value: MailSettingsViewLayout) -> RustBuffer {
    return FfiConverterTypeMailSettingsViewLayout.lower(value)
}


extension MailSettingsViewLayout: Sendable {} 
extension MailSettingsViewLayout: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MailSettingsViewMode : UInt8 {
    
    case conversations = 0
    case messages = 1
}


public struct FfiConverterTypeMailSettingsViewMode: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsViewMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MailSettingsViewMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .conversations
        
        case 2: return .messages
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MailSettingsViewMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .conversations:
            writeInt(&buf, Int32(1))
        
        
        case .messages:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMailSettingsViewMode_lift(_ buf: RustBuffer) throws -> MailSettingsViewMode {
    return try FfiConverterTypeMailSettingsViewMode.lift(buf)
}

public func FfiConverterTypeMailSettingsViewMode_lower(_ value: MailSettingsViewMode) -> RustBuffer {
    return FfiConverterTypeMailSettingsViewMode.lower(value)
}


extension MailSettingsViewMode: Sendable {} 
extension MailSettingsViewMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageMetadataSortMode {
    
    case time
    case size
    case id
}


public struct FfiConverterTypeMessageMetadataSortMode: FfiConverterRustBuffer {
    typealias SwiftType = MessageMetadataSortMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageMetadataSortMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .time
        
        case 2: return .size
        
        case 3: return .id
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageMetadataSortMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .time:
            writeInt(&buf, Int32(1))
        
        
        case .size:
            writeInt(&buf, Int32(2))
        
        
        case .id:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMessageMetadataSortMode_lift(_ buf: RustBuffer) throws -> MessageMetadataSortMode {
    return try FfiConverterTypeMessageMetadataSortMode.lift(buf)
}

public func FfiConverterTypeMessageMetadataSortMode_lower(_ value: MessageMetadataSortMode) -> RustBuffer {
    return FfiConverterTypeMessageMetadataSortMode.lower(value)
}


extension MessageMetadataSortMode: Sendable {} 
extension MessageMetadataSortMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MimeType {
    
    case textPlain
    case textHtml
    case multipartMixed
    case multipartRelated
    case messageRfc822
}


public struct FfiConverterTypeMimeType: FfiConverterRustBuffer {
    typealias SwiftType = MimeType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MimeType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .textPlain
        
        case 2: return .textHtml
        
        case 3: return .multipartMixed
        
        case 4: return .multipartRelated
        
        case 5: return .messageRfc822
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MimeType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .textPlain:
            writeInt(&buf, Int32(1))
        
        
        case .textHtml:
            writeInt(&buf, Int32(2))
        
        
        case .multipartMixed:
            writeInt(&buf, Int32(3))
        
        
        case .multipartRelated:
            writeInt(&buf, Int32(4))
        
        
        case .messageRfc822:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeMimeType_lift(_ buf: RustBuffer) throws -> MimeType {
    return try FfiConverterTypeMimeType.lift(buf)
}

public func FfiConverterTypeMimeType_lower(_ value: MimeType) -> RustBuffer {
    return FfiConverterTypeMimeType.lower(value)
}


extension MimeType: Sendable {} 
extension MimeType: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMailSettingsMobileSettings: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsMobileSettings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMailSettingsMobileSettings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMailSettingsMobileSettings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMailSettingsNextMessageOnMove: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsNextMessageOnMove?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMailSettingsNextMessageOnMove.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMailSettingsNextMessageOnMove.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMailSettingsSpamAction: FfiConverterRustBuffer {
    typealias SwiftType = MailSettingsSpamAction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMailSettingsSpamAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMailSettingsSpamAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessageMetadataSortMode: FfiConverterRustBuffer {
    typealias SwiftType = MessageMetadataSortMode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageMetadataSortMode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageMetadataSortMode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeConversationId: FfiConverterRustBuffer {
    typealias SwiftType = [ConversationId]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeConversationId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeConversationId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeLabelId: FfiConverterRustBuffer {
    typealias SwiftType = [LabelId]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLabelId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLabelId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeMessageId: FfiConverterRustBuffer {
    typealias SwiftType = [MessageId]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeMessageId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeMessageId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAddressId: FfiConverterRustBuffer {
    typealias SwiftType = AddressId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddressId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddressId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeConversationId: FfiConverterRustBuffer {
    typealias SwiftType = ConversationId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConversationId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConversationId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeExternalId: FfiConverterRustBuffer {
    typealias SwiftType = ExternalId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeExternalId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeExternalId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLabelId: FfiConverterRustBuffer {
    typealias SwiftType = LabelId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLabelId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLabelId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessageId: FfiConverterRustBuffer {
    typealias SwiftType = MessageId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeConversationId: FfiConverterRustBuffer {
    typealias SwiftType = [ConversationId]

    public static func write(_ value: [ConversationId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeConversationId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ConversationId] {
        let len: Int32 = try readInt(&buf)
        var seq = [ConversationId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeConversationId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLabelId: FfiConverterRustBuffer {
    typealias SwiftType = [LabelId]

    public static func write(_ value: [LabelId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLabelId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LabelId] {
        let len: Int32 = try readInt(&buf)
        var seq = [LabelId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLabelId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMessageId: FfiConverterRustBuffer {
    typealias SwiftType = [MessageId]

    public static func write(_ value: [MessageId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessageId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MessageId] {
        let len: Int32 = try readInt(&buf)
        var seq = [MessageId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessageId.read(from: &buf))
        }
        return seq
    }
}




/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias AttachmentId = String
public struct FfiConverterTypeAttachmentId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: AttachmentId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> AttachmentId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: AttachmentId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeAttachmentId_lift(_ value: RustBuffer) throws -> AttachmentId {
    return try FfiConverterTypeAttachmentId.lift(value)
}

public func FfiConverterTypeAttachmentId_lower(_ value: AttachmentId) -> RustBuffer {
    return FfiConverterTypeAttachmentId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ConversationId = String
public struct FfiConverterTypeConversationId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversationId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ConversationId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ConversationId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ConversationId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeConversationId_lift(_ value: RustBuffer) throws -> ConversationId {
    return try FfiConverterTypeConversationId.lift(value)
}

public func FfiConverterTypeConversationId_lower(_ value: ConversationId) -> RustBuffer {
    return FfiConverterTypeConversationId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ExternalId = String
public struct FfiConverterTypeExternalId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ExternalId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ExternalId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ExternalId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeExternalId_lift(_ value: RustBuffer) throws -> ExternalId {
    return try FfiConverterTypeExternalId.lift(value)
}

public func FfiConverterTypeExternalId_lower(_ value: ExternalId) -> RustBuffer {
    return FfiConverterTypeExternalId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LabelId = String
public struct FfiConverterTypeLabelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: LabelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> LabelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: LabelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeLabelId_lift(_ value: RustBuffer) throws -> LabelId {
    return try FfiConverterTypeLabelId.lift(value)
}

public func FfiConverterTypeLabelId_lower(_ value: LabelId) -> RustBuffer {
    return FfiConverterTypeLabelId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias MessageFlags = UInt64
public struct FfiConverterTypeMessageFlags: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageFlags {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: MessageFlags, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> MessageFlags {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: MessageFlags) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


public func FfiConverterTypeMessageFlags_lift(_ value: UInt64) throws -> MessageFlags {
    return try FfiConverterTypeMessageFlags.lift(value)
}

public func FfiConverterTypeMessageFlags_lower(_ value: MessageFlags) -> UInt64 {
    return FfiConverterTypeMessageFlags.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias MessageId = String
public struct FfiConverterTypeMessageId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: MessageId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> MessageId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: MessageId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeMessageId_lift(_ value: RustBuffer) throws -> MessageId {
    return try FfiConverterTypeMessageId.lift(value)
}

public func FfiConverterTypeMessageId_lower(_ value: MessageId) -> RustBuffer {
    return FfiConverterTypeMessageId.lower(value)
}


private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_proton_api_mail_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all